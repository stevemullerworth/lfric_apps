!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains routine for transporting a field collection of tracers.

module tracer_collection_transport_mod

  use constants_mod,                  only: r_def, i_def, r_tran
  use field_mod,                      only: field_type
  use field_parent_mod,               only: field_parent_type
  use r_tran_field_mod,               only: r_tran_field_type
  use field_collection_mod,           only: field_collection_type
  use field_collection_iterator_mod,  only: field_collection_iterator_type
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use io_config_mod,                  only: subroutine_timers
  use log_mod,                        only: log_event,       &
                                            LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_INFO
  use timer_mod,                      only: timer
  use transport_enumerated_types_mod, only: equation_form_advective,    &
                                            equation_form_conservative, &
                                            equation_form_consistent
  use transport_field_mod,            only: transport_field
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_runtime_alg_mod,      only: transport_runtime_type
  use transport_runtime_collection_mod, &
                                      only: get_transport_runtime
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use extrusion_mod,                  only: SHIFTED
  use sci_enforce_lower_bound_kernel_mod, &
                                      only: enforce_lower_bound_kernel_type
  use transport_rho_times_field_alg_mod, &
                                      only: transport_rho_times_field_alg

  implicit none

  private

  public :: tracer_collection_transport_alg
  public :: coarse_collection_transport_alg

contains

  !> @brief Central routine for transporting a field collection of tracers.
  !> @details Performs a whole transport time step for a field collection of
  !!          tracers, for instance the cloud fields.
  !> @param[in,out] fields_out         Tracer field collection after transport
  !> @param[in]     fields_in          Tracer field collection before transport
  !> @param[in]     model_dt_r_def           Model timestep
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields

  subroutine tracer_collection_transport_alg(fields_out, &
                                             fields_in,  &
                                             model_dt_r_def,   &
                                             transport_metadata)

    implicit none

    ! Arguments
    type(field_collection_type),   intent(inout) :: fields_out
    type(field_collection_type),   intent(in)    :: fields_in
    real(kind=r_def),              intent(in)    :: model_dt_r_def
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Iterator for field collection
    type(field_collection_iterator_type) :: iterator

    ! One of the single fields out of the fields_out collection
    type(field_type), pointer :: single_field_out

    ! The saved version of field after slow physics
    class( field_parent_type ), pointer :: abstract_field_ptr
    type(field_type), pointer :: single_field_in

    ! Transport runtime and form of transport equation
    type(transport_runtime_type), pointer :: transport_runtime
    integer(kind=i_def)                   :: equation_form

    if ( subroutine_timers ) call timer('transport.tracer_collection')

      if ( fields_in%get_length() > 0 ) then

        call iterator%initialise( fields_in )

        do
          if ( .not. iterator%has_next() ) exit

          abstract_field_ptr => iterator%next()
          select type(abstract_field_ptr)
          type is (field_type)
            single_field_in => abstract_field_ptr
          end select
          call fields_out%get_field( trim(single_field_in%get_name() ), &
                                     single_field_out )

          call log_event( "Advecting "//  trim(single_field_in%get_name()), &
                           LOG_LEVEL_INFO)

          ! Get correct equation form depending on advective form flag
          transport_runtime => get_transport_runtime(single_field_in%get_mesh())
          if ( transport_runtime%get_advective_flag() ) then
            equation_form = equation_form_advective
          else
            equation_form = transport_metadata%get_equation_form()
          end if
          nullify( transport_runtime )

          ! ------------------------------------------------------------------------ !
          ! Transport depending on equation
          ! If the equation form is advective:
          !           Simply transport field in native space
          ! If the equation form is consistent:
          !           Requires transformation to densities and evaluation of fluxes.
          !           This is done in the lowest level algorithms, so can just call
          !           transport_field.
          ! If the equation form is conservative:
          !           This also requires transformation to densities and evaluation
          !           of fluxes, but is achieved using the transport_rho_times_field
          !           algorithm (this also divides the result by density at the end
          !           of the transport step and so returns an updated field.)
          ! ------------------------------------------------------------------------ !
          select case ( equation_form )

            ! ------------------------------------------------------------------------ !
            ! Advective and consistent forms of transport equation
            ! ------------------------------------------------------------------------ !
          case ( equation_form_advective, equation_form_consistent )

            call transport_field(single_field_out, single_field_in, model_dt_r_def, &
                                 transport_metadata)


            ! ---------------------------------------------------------------------- !
            ! Conservative form of transport equation
            ! ---------------------------------------------------------------------- !
          case ( equation_form_conservative )

            call transport_rho_times_field_alg(single_field_out, single_field_in, &
                                               model_dt_r_def, transport_metadata)

            ! ---------------------------------------------------------------------- !
            ! Default form of transport equation
            ! ---------------------------------------------------------------------- !
          case default
            call log_event('Form of tracer collection transport equation either ' // &
                           'not compatible or not implemented', LOG_LEVEL_ERROR)

          end select
        end do ! if ( .not. iterator%has_next() ) exit
      end if ! fields_in%get_length() > 0

    if ( subroutine_timers ) call timer('transport.tracer_collection')

  end subroutine tracer_collection_transport_alg


  !> @brief Transports a collection of tracers on a coarser mesh.
  !> @details Performs a whole transport time step for a field collection of
  !!          tracers, mapping them first to a coarser mesh.
  !> @param[in,out] fields_out         Tracer field collection after transport
  !> @param[in]     fields_in          Tracer field collection before transport
  !> @param[in]     model_dt           Model timestep
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine coarse_collection_transport_alg(fields_out, fields_in, model_dt, &
                                             transport_metadata)

    use finite_element_config_mod,     only: element_order_h, element_order_v
    use function_space_collection_mod, only: function_space_collection
    use function_space_mod,            only: function_space_type
    use intermesh_mappings_alg_mod,    only: map_scalar_intermesh
    use mesh_collection_mod,           only: mesh_collection
    use mesh_mod,                      only: mesh_type
    use multires_coupling_config_mod,  only: aerosol_mesh_name

    implicit none

    ! Arguments
    type(field_collection_type),   intent(inout) :: fields_out
    type(field_collection_type),   intent(in)    :: fields_in
    real(kind=r_def),              intent(in)    :: model_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Iterator for field collection
    type(field_collection_iterator_type) :: iterator

    ! One of the single fields out of the fields_out collection
    class( field_parent_type ), pointer :: abstract_field_ptr
    type(field_type), pointer :: single_field_out

    ! The saved version of field after slow physics
    type(field_type), pointer :: single_field_in

    ! Coarse mesh objects
    type(mesh_type),           pointer :: coarse_mesh
    type(function_space_type), pointer :: coarse_fs
    type(field_type)                   :: coarse_field_in, coarse_field_out

    ! Transport runtime and form of transport equation
    type(transport_runtime_type), pointer :: transport_runtime
    integer(kind=i_def)                   :: equation_form

    if ( subroutine_timers ) call timer('transport.tracer_collection')


    if ( fields_in%get_length() > 0 ) then

      call iterator%initialise( fields_in )

      do
        if ( .not. iterator%has_next() ) exit

        abstract_field_ptr => iterator%next()
        select type(abstract_field_ptr)
        type is (field_type)
          single_field_in => abstract_field_ptr
        end select
        call fields_out%get_field( trim(single_field_in%get_name() ), &
                                   single_field_out )
        call log_event( "Advecting "//  trim(single_field_in%get_name()), &
                                LOG_LEVEL_INFO)

        coarse_mesh => mesh_collection%get_mesh(aerosol_mesh_name)
        coarse_fs => function_space_collection%get_fs(coarse_mesh, element_order_h, &
                                                        element_order_v,            &
                                                        single_field_in%which_function_space())
        call coarse_field_in%initialise(coarse_fs)
        call coarse_field_out%initialise(coarse_fs)

        ! Get correct equation form depending on advective form flag
        transport_runtime => get_transport_runtime(single_field_in%get_mesh())
        if ( transport_runtime%get_advective_flag() ) then
          equation_form = equation_form_advective
        else
          equation_form = transport_metadata%get_equation_form()
        end if
        nullify( transport_runtime )

        ! Map to coarse mesh ----------------------------------------------- !
        call map_scalar_intermesh(coarse_field_in, single_field_in)

        ! Choose form of transport equation
        select case ( equation_form )

          ! ------------------------------------------------------------------------ !
          ! Advective form of transport equation
          ! ------------------------------------------------------------------------ !
        case ( equation_form_advective, equation_form_consistent )

          ! Transport on coarse mesh ----------------------------------------- !
          call transport_field(coarse_field_out, coarse_field_in, model_dt, &
                               transport_metadata)

          ! ---------------------------------------------------------------------- !
          ! Conservative form of transport equation
          ! ---------------------------------------------------------------------- !
        case ( equation_form_conservative )

          ! Transport on coarse mesh ----------------------------------------- !
          call transport_rho_times_field_alg(coarse_field_out, coarse_field_in, &
                                             model_dt, transport_metadata)

          ! ---------------------------------------------------------------------- !
          ! Default form of transport equation
          ! ---------------------------------------------------------------------- !
        case default
          call log_event('Form of tracer collection transport equation either ' // &
                         'not compatible or not implemented', LOG_LEVEL_ERROR)

        end select

        ! Map to dynamics mesh --------------------------------------------- !
        call map_scalar_intermesh(single_field_out, coarse_field_out)

      end do

    end if

    if ( subroutine_timers ) call timer('transport.tracer_collection')

  end subroutine coarse_collection_transport_alg

end module tracer_collection_transport_mod
