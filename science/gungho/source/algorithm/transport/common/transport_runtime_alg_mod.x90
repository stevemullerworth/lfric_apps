!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief A module that controls set-up of various transport objects.
!> @details This module controls the set-up of various objects that are
!!          created at the start of (or during) the transport process, and
!!          are needed throughout the transport routines.

module transport_runtime_alg_mod

  use base_mesh_config_mod,           only: geometry, topology,              &
                                            geometry_spherical,              &
                                            topology_fully_periodic
  use check_configuration_mod,        only: check_any_scheme_mol,            &
                                            check_any_scheme_ffsl,           &
                                            check_any_scheme_split,          &
                                            check_any_scheme_slice,          &
                                            check_any_scheme_split_ffsl,     &
                                            check_any_horizontal_method_mol, &
                                            check_any_hori_scheme_sl,        &
                                            check_any_vert_scheme_sl,        &
                                            check_any_reversible_sl,         &
                                            check_wind_shifted,              &
                                            check_horz_dep_pts,              &
                                            check_vert_dep_pts,              &
                                            check_any_splitting_vhv,         &
                                            check_any_splitting_hvh,         &
                                            check_any_eqn_consistent,        &
                                            check_any_advective_swift,       &
                                            check_any_consistent_swift,      &
                                            check_any_consistent_cosmic,     &
                                            get_required_stencil_depth
  use constants_mod,                  only: r_def, r_second, i_def, l_def,   &
                                            str_def, tiny_eps, imdi, r_tran, &
                                            EPS_R_TRAN
  use departure_points_config_mod,    only: horizontal_limit, &
                                            horizontal_limit_cap
  use extrusion_mod,                  only: SHIFTED, TWOD
  use field_mod,                      only: field_type
  use sci_field_minmax_alg_mod,       only: get_field_minmax, &
                                            log_field_minmax
  use finite_element_config_mod,      only: element_order_h, element_order_v
  use fs_continuity_mod,              only: W2, W2h, W2v, W3, Wtheta
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use sci_geometric_constants_mod,    only: get_panel_id,         &
                                            get_face_selector_ew, &
                                            get_face_selector_ns
  use integer_field_mod,              only: integer_field_type
  use io_config_mod,                  only: subroutine_timers
  use local_mesh_mod,                 only: local_mesh_type
  use log_mod,                        only: log_event,            &
                                            log_scratch_space,    &
                                            LOG_LEVEL_ERROR,      &
                                            LOG_LEVEL_DEBUG,      &
                                            LOG_LEVEL_INFO,       &
                                            log_level
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use model_clock_mod,                only: model_clock_type
  use remap_on_extended_mesh_alg_mod, only: remap_on_extended_mesh
  use r_tran_field_mod,               only: r_tran_field_type
  use runtime_tools_mod,              only: check_initialised_field
  use timer_mod,                      only: timer
  use timestepping_config_mod,        only: outer_iterations
  use transport_config_mod,           only: extended_mesh,           &
                                            special_edges_treatment, &
                                            dep_pt_stencil_extent,   &
                                            ffsl_outer_order,        &
                                            ffsl_inner_order,        &
                                            adjust_vhv_wind,         &
                                            substep_transport,       &
                                            substep_transport_off,   &
                                            substep_transport_adaptive
  use transport_constants_mod,        only: get_detj_at_w3_r_tran
  use transport_enumerated_types_mod, only: scheme_split,         &
                                            direction_h,          &
                                            direction_v,          &
                                            direction_3d,         &
                                            splitting_strang_hvh, &
                                            splitting_strang_vhv, &
                                            splitting_hv,         &
                                            splitting_vh,         &
                                            splitting_none,       &
                                            split_method_null

  use copy_field_alg_mod,             only: copy_field
  use psykal_lite_transport_mod,      only: invoke_deep_X_times_Y
  use lipschitz_diag_alg_mod,         only: lipschitz_diag_alg
  use ffsl_panel_swap_kernel_mod,     only: ffsl_panel_swap_kernel_type

  implicit none

  private

  ! Public types
  ! TODO #3008: this should be based on a linked_list_item type
  type, public :: transport_runtime_type

    private

    integer(kind=i_def)                                       :: n_meshes
    integer(kind=i_def)                                       :: local_mesh_id
    integer(kind=i_def)                                       :: num_dry_steps
    integer(kind=i_def)                                       :: tracer_step_ctr
    integer(kind=i_def)                                       :: substep_total_ctr
    integer(kind=i_def),        allocatable, dimension(:)     :: mesh_ids
    integer(kind=i_def),        allocatable, dimension(:)     :: dep_stencil_extent_xy
    integer(kind=i_def),        allocatable, dimension(:)     :: dep_stencil_extent_oxy
    integer(kind=i_def),        allocatable, dimension(:,:)   :: tracer_stencil_extent_ixy
    integer(kind=i_def),        allocatable, dimension(:,:)   :: tracer_stencil_extent_oxy
    integer(kind=i_def),        allocatable, dimension(:,:)   :: unity_stencil_extent_ixy
    integer(kind=i_def),        allocatable, dimension(:,:)   :: unity_stencil_extent_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)     :: horizontal_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)     :: vertical_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: adjusted_v_wind
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_xy_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_xy_half_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_oxy_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_oxy_half_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_z_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_z_half_w2
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: unity_dep_dist_z
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: unity_dep_dist_ixy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: unity_dep_dist_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_z
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_z_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_xy
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_xy_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_oxy_half
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: unity_frac_wind_z
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: unity_frac_wind_ixy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: unity_frac_wind_oxy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: tracer_dep_dist_z
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: tracer_dep_dist_ixy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: tracer_dep_dist_oxy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_frac_flux_z
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_frac_flux_ixy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_frac_flux_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_x
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_y
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_z
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_half_x
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_half_y
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_half_z
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_x
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_y
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_xy
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_x_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_y_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_xy_half
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: detj_unity
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: detj_unity_x
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: detj_unity_y
    type(r_tran_field_type)                                   :: field_n
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: rho_d
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_mass
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_mass_ffsl_x
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_mass_ffsl_y
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: total_rho_d
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: total_dry_mass
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: total_dry_mass_ffsl_x
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: total_dry_mass_ffsl_y
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: flux
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_flux
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: total_dry_flux
    type(r_tran_field_type),    allocatable, dimension(:,:,:) :: vert_cubic_coef
    type(integer_field_type),   allocatable, dimension(:,:,:) :: vert_cubic_index
    type(r_tran_field_type),    allocatable, dimension(:,:,:) :: vert_quintic_coef
    type(integer_field_type),   allocatable, dimension(:,:,:) :: vert_quintic_index
    type(r_tran_field_type),    allocatable, dimension(:,:,:) :: vert_linear_coef
    real(kind=r_tran),          allocatable, dimension(:)     :: horizontal_cfl_max
    real(kind=r_tran),          allocatable, dimension(:)     :: vertical_cfl_max
    real(kind=r_tran),          allocatable, dimension(:)     :: total_cfl_max
    class(model_clock_type),    pointer                       :: model_clock
    logical(kind=l_def)                                       :: advective_first_outer
    logical(kind=l_def)                                       :: no_mono_first_outer
    logical(kind=l_def)                                       :: rho_monotone_remap
    logical(kind=l_def)                                       :: rho_enforce_minvalue
    real(kind=r_tran)                                         :: rho_minvalue
    type(r_tran_field_type)                                   :: remap_weights
    type(integer_field_type)                                  :: remap_indices
    logical(kind=l_def)                                       :: apply_cheap_update
    logical(kind=l_def)                                       :: cheap_update_flag
    logical(kind=l_def)                                       :: computed_remapping
    logical(kind=l_def)                                       :: computed_dep_pt_idxs
    integer(kind=i_def)                                       :: number_total_substeps
    integer(kind=i_def)                                       :: dry_config
    logical(kind=l_def)                                       :: dry_config_found

    contains

    procedure, private :: idx_from_mesh_id
    procedure, private :: compute_num_dry_steps
    procedure, private :: check_negative_field
    procedure, private :: find_dry_config
    procedure, public  :: direction_w2_fs
    procedure, public  :: splitting_fraction
    procedure, public  :: get_local_mesh_id
    procedure, public  :: get_prime_extrusion_mesh_id
    procedure, public  :: restrict_dry_fields
    procedure, public  :: shift_dry_fields
    procedure, public  :: compute_consistent_quantities
    procedure, public  :: compute_total_rho_quantities
    procedure, public  :: get_number_total_substeps
    procedure, public  :: get_number_mol_substeps
    procedure, public  :: get_dt_substep
    procedure, public  :: get_advecting_wind
    procedure, public  :: get_directional_advecting_wind
    procedure, public  :: get_horizontal_advecting_wind
    procedure, public  :: get_vertical_advecting_wind
    procedure, public  :: get_adjusted_v_wind
    procedure, public  :: get_dep_dist_z_w2
    procedure, public  :: get_dep_dist_xy_w2
    procedure, public  :: get_unity_dep_dist_z
    procedure, public  :: get_unity_dep_dist_xy
    procedure, public  :: get_frac_wind_z
    procedure, public  :: get_frac_wind_xy
    procedure, public  :: get_unity_frac_wind_z
    procedure, public  :: get_unity_frac_wind_xy
    procedure, public  :: get_tracer_dep_dist_z
    procedure, public  :: get_tracer_dep_dist_xy
    procedure, public  :: get_dry_frac_flux_z
    procedure, public  :: get_dry_frac_flux_xy
    procedure, public  :: get_dep_stencil_extent_xy
    procedure, public  :: get_tracer_stencil_extent_xy
    procedure, public  :: get_unity_stencil_extent_xy
    procedure, public  :: get_adv_unity_x
    procedure, public  :: get_adv_unity_y
    procedure, public  :: get_adv_unity_z
    procedure, public  :: get_adv_detj_x
    procedure, public  :: get_adv_detj_y
    procedure, public  :: get_adv_detj_xy
    procedure, public  :: get_detj_unity_x
    procedure, public  :: get_detj_unity_y
    procedure, public  :: get_detj_unity
    procedure, public  :: get_vert_sl_coef
    procedure, public  :: get_vert_sl_index
    procedure, public  :: get_field_n
    procedure, public  :: set_field_n
    procedure, public  :: get_rho_d
    procedure, public  :: set_rho_d
    procedure, public  :: get_dry_mass
    procedure, public  :: get_dry_mass_ffsl_x
    procedure, public  :: set_rho_d_ffsl_x
    procedure, public  :: get_dry_mass_ffsl_y
    procedure, public  :: set_rho_d_ffsl_y
    procedure, public  :: get_flux
    procedure, public  :: set_flux
    procedure, public  :: get_dry_flux
    procedure, public  :: set_dry_flux
    procedure, public  :: set_apply_cheap_update
    procedure, public  :: get_apply_cheap_update
    procedure, public  :: get_num_dry_steps
    procedure, public  :: get_tracer_step_ctr
    procedure, public  :: inc_tracer_step_ctr
    procedure, public  :: reset_tracer_step_ctr
    procedure, public  :: get_substep_total_ctr
    procedure, public  :: set_substep_total_ctr
    procedure, public  :: get_substep_total_index
    procedure, public  :: get_advective_flag
    procedure, public  :: get_no_mono_flag
    procedure, public  :: initialise => transport_runtime_initialiser
    final              :: destroy_transport_runtime

  end type transport_runtime_type

  !-----------------------------------------------------------------------------
  ! Constructors
  !-----------------------------------------------------------------------------

contains

  !> @brief Constructs the transport_runtime object
  !> @param[in,out] self                  Transport runtime object to set
  !> @param[in]     primal_wind_n_rdef    Wind field at start of current time step on the
  !!                                      prime extrusion
  !> @param[in]     primal_wind_np1_rdef  Predictor of wind field at next time step on
  !!                                      the prime extrusion
  !> @param[in]     model_clock           Time within the model
  !> @param[in]     outer                 Outer (advection) iteration number
  !> @param[in]     cheap_update          Logical flag for cheap transport update
  !> @param[in]     rho_d_n_rdef          Start of transport dry density
  !> @param[in]     shifted_mesh          (Optional) Shifted mesh
  !>
  subroutine transport_runtime_initialiser( self,                 &
                                            primal_wind_n_rdef,   &
                                            primal_wind_np1_rdef, &
                                            model_clock,          &
                                            outer,                &
                                            cheap_update,         &
                                            rho_d_n_rdef,         &
                                            shifted_mesh )

    use calc_dep_pts_alg_mod,          only: calc_vert_dep_pts,      &
                                             calc_hori_dep_pts,      &
                                             calc_ffsl_hori_dep_pts, &
                                             select_detj_at_w2
    use compute_sl_coefficients_alg_mod, &
                                       only: compute_vert_quintic_coefficients_alg, &
                                             compute_vert_cubic_coefficients_alg
    use ffsl_unity_transport_alg_mod,  only: ffsl_unity_transport_alg, &
                                             ffsl_unity_swift_alg
    use substep_transport_alg_mod,     only: substep_transport_alg
    use split_w2_field_kernel_mod,     only: split_w2_field_kernel_type
    use transport_config_mod,          only: max_vert_cfl_calc,            &
                                             max_vert_cfl_calc_dep_point,  &
                                             max_vert_cfl_calc_uniform,    &
                                             ffsl_unity_3d,                &
                                             horizontal_method,            &
                                             vertical_method,              &
                                             si_outer_transport,           &
                                             si_outer_transport_advective, &
                                             si_outer_transport_no_mono,   &
                                             vertical_sl_order,            &
                                             vertical_sl_order_cubic,      &
                                             vertical_sl_order_quintic,    &
                                             vertical_sl_order_cubic_hermite
    use map_w2_to_sh_w2_alg_mod,       only: sample_w2_to_sh_w2_alg
    use calc_max_cfl_kernel_mod,       only: calc_max_cfl_kernel_type
    use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
    use r_tran_operator_mod,           only: r_tran_operator_type
    use fv_difference_x_kernel_mod,    only: fv_difference_x_kernel_type
    use fv_difference_y_kernel_mod,    only: fv_difference_y_kernel_type
    use fv_difference_z_kernel_mod,    only: fv_difference_z_kernel_type
    use vert_dep_dist_ffsl_kernel_mod, only: vert_dep_dist_ffsl_kernel_type
    use watkins_kernel_mod,            only: watkins_kernel_type

    implicit none

    class(transport_runtime_type), intent(inout) :: self

    type(field_type),        target, intent(in) :: primal_wind_n_rdef
    type(field_type),        target, intent(in) :: primal_wind_np1_rdef
    class(model_clock_type), target, intent(in) :: model_clock
    integer(kind=i_def),             intent(in) :: outer
    logical(kind=l_def),             intent(in) :: cheap_update
    type(field_type),      optional, intent(in) :: rho_d_n_rdef

    type(mesh_type),  pointer, intent(in), optional :: shifted_mesh

    type(r_tran_field_type)          :: cfl, vertical_cfl, horizontal_cfl
    type(r_tran_field_type)          :: cfl_dep, cfl_dep_half
    type(r_tran_field_type)          :: sum_cfl, sum_horizontal_cfl, hori_cfl_dep
    type(r_tran_field_type)          :: dep_pt_wind_n, dep_pt_wind_np1
    type(r_tran_field_type)          :: unity_field, increment, detj_copy
    type(r_tran_field_type)          :: unity_x, unity_y
    type(r_tran_field_type)          :: hori_wind_dt, vert_wind_dt
    type(r_tran_field_type), pointer :: hori_wind, vert_wind
    type(field_type),        pointer :: panel_id
    integer(kind=i_def)              :: mesh_idx, num_compute_meshes
    integer(kind=i_def)              :: n_steps, n_meshes, i_coef, step
    integer(kind=i_def)              :: n_steps_with_substep, np1_steps_with_substep
    integer(kind=i_def)              :: halo_depth
    type(mesh_type),         pointer :: mesh => null()
    type(local_mesh_type),   pointer :: local_mesh => null()
    type(r_tran_field_type), pointer :: wind_n   => null()
    type(r_tran_field_type), pointer :: wind_np1 => null()
    type(r_tran_field_type), target  :: shifted_wind_n
    type(r_tran_field_type), target  :: shifted_wind_np1
    type(field_type),        target  :: shifted_wind_n_rdef
    type(field_type),        target  :: shifted_wind_np1_rdef
    type(r_tran_field_type)          :: detj_at_w2_transport
    type(r_tran_field_type)          :: remapped_unity, adv_unity_xy
    real(kind=r_tran)                :: cfl_min, cfl_max
    real(kind=r_tran)                :: h_cfl_min, h_cfl_max
    real(kind=r_tran)                :: v_cfl_min, v_cfl_max
    real(r_tran)                     :: cast_dt, half_dt, step_dt
    logical(kind=l_def)              :: any_scheme_mol, any_scheme_split
    logical(kind=l_def)              :: any_scheme_ffsl
    logical(kind=l_def)              :: any_wind_shifted
    logical(kind=l_def)              :: any_splitting_vhv, any_splitting_hvh
    logical(kind=l_def)              :: any_scheme_slice, any_scheme_split_ffsl
    logical(kind=l_def)              :: any_hori_scheme_sl, any_vert_scheme_sl
    logical(kind=l_def)              :: any_reversible_sl
    logical(kind=l_def)              :: any_advective_swift
    logical(kind=l_def)              :: any_consistent_swift
    logical(kind=l_def)              :: any_horz_dep_dist, any_vert_dep_dist
    logical(kind=l_def)              :: hermite_sl, vhv_split_sl
    logical(kind=l_def)              :: compute_cfl_dep
    integer(kind=i_def)              :: watkins_fail, watkins_min
    type(integer_field_type)         :: watkins_fail_field
    integer(kind=i_def)              :: remap_depth

    type(mesh_type),           pointer :: tmp_mesh => null()
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: wt_fs => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()
    type(function_space_type), pointer :: w3_2d_fs => null()
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(r_tran_field_type),   pointer :: detj_at_w3 => null()

    ! r_tran type fields
    type(r_tran_field_type), target :: primal_wind_n
    type(r_tran_field_type), target :: primal_wind_np1
    type(r_tran_field_type)         :: rho_d_n

    if ( subroutine_timers ) call timer('transport.runtime_init')

    write(log_scratch_space, '(A,I4)') 'Setting up transport_runtime on mesh: ', &
                                       primal_wind_n_rdef%get_mesh_id()
    call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

    ! Proxy for the first time the object is initialised
    if ( .not. allocated(self%mesh_ids) ) self%computed_remapping = .false.
    if ( .not. allocated(self%mesh_ids) ) self%computed_dep_pt_idxs = .false.
    if ( .not. allocated(self%mesh_ids) ) self%dry_config_found = .false.

    ! If not already found, work out which config is for dry field and save this
    ! so that it doesn't need finding again
    if ( .not. self%dry_config_found ) call self%find_dry_config()

    ! TODO: options for remapping density are hard-wired
    ! They could be options in the future
    self%rho_monotone_remap = .true.
    self%rho_enforce_minvalue = .true.
    self%rho_minvalue = 0.0_r_tran

    ! Transfer r_def input to r_tran fields
    call primal_wind_n%initialise(vector_space = primal_wind_n_rdef%get_function_space() )
    call primal_wind_np1%initialise(vector_space = primal_wind_np1_rdef%get_function_space() )
    call copy_field(primal_wind_n_rdef, primal_wind_n)
    call copy_field(primal_wind_np1_rdef, primal_wind_np1)

    ! ======================================================================== !
    ! Checks for what schemes we have

    any_scheme_mol = check_any_scheme_mol()
    any_scheme_ffsl = check_any_scheme_ffsl()
    any_scheme_split = check_any_scheme_split()
    any_scheme_slice = check_any_scheme_slice()
    any_horz_dep_dist = check_horz_dep_pts()
    any_vert_dep_dist = check_vert_dep_pts()
    any_splitting_vhv = check_any_splitting_vhv()
    any_splitting_hvh = check_any_splitting_hvh()
    any_reversible_sl = check_any_reversible_sl()
    any_hori_scheme_sl = check_any_hori_scheme_sl()
    any_vert_scheme_sl = check_any_vert_scheme_sl()
    any_wind_shifted = check_wind_shifted()
    any_scheme_split_ffsl = check_any_scheme_split_ffsl()
    any_advective_swift = check_any_advective_swift()
    any_consistent_swift = check_any_consistent_swift()
    compute_cfl_dep = ((any_scheme_mol .or. log_level() <= LOG_LEVEL_INFO) &
                       .and. max_vert_cfl_calc == max_vert_cfl_calc_dep_point)

    ! Check whether it is a cheap update step
    self%cheap_update_flag  = .false.
    self%apply_cheap_update = .false.
    if (cheap_update) then
      self%cheap_update_flag = .true.
      if (outer > 1) then
        self%apply_cheap_update = .true.
      end if
    end if

    ! Set logicals for semi-implicit first outer iteration transport
    if (outer < outer_iterations .AND. si_outer_transport==si_outer_transport_advective) then
      self%advective_first_outer = .true.
    else
      self%advective_first_outer = .false.
    end if
    if (outer < outer_iterations .AND. si_outer_transport==si_outer_transport_no_mono) then
      self%no_mono_first_outer = .true.
    else
      self%no_mono_first_outer = .false.
    end if

    ! ======================================================================== !
    ! Determine number of meshes

    ! By default only compute auxiliary fields on prime extrusion mesh
    num_compute_meshes = 1

    if ( present(shifted_mesh) ) then
      self%n_meshes = 2
      ! Only compute things on the shifted mesh if we need to
      if (any_wind_shifted) then
        num_compute_meshes = 2
      end if
    else
      self%n_meshes = 1
    end if

    ! Dry fields stored for consistent transport of scalars
    self%num_dry_steps = self%compute_num_dry_steps()

    !> @todo This is almost certainly the wrong thing to do but I want to get
    !>       something done.
    !>
    self%model_clock => model_clock
    cast_dt = real( model_clock%get_seconds_per_step(), r_tran )

    ! Set number of transport substeps to 1
    self%number_total_substeps = 1_i_def

    mesh => primal_wind_n_rdef%get_mesh()
    local_mesh => mesh%get_local_mesh()
    self%local_mesh_id = local_mesh%get_id()

    if (.not. allocated( self%mesh_ids ) ) then
      if ( subroutine_timers ) call timer('transport.runtime_allocate')

      allocate( self%mesh_ids(self%n_meshes),                   &
                self%advecting_wind(self%n_meshes),             &
                self%horizontal_advecting_wind(self%n_meshes),  &
                self%vertical_advecting_wind(self%n_meshes),    &
                self%adjusted_v_wind(self%n_meshes, 2),         &
                self%dep_dist_z_w2(self%n_meshes),              &
                self%dep_dist_z_half_w2(self%n_meshes),         &
                self%dep_dist_xy_w2(self%n_meshes),             &
                self%dep_dist_xy_half_w2(self%n_meshes),        &
                self%dep_dist_oxy_w2(self%n_meshes),            &
                self%dep_dist_oxy_half_w2(self%n_meshes),       &
                self%frac_wind_z(self%n_meshes),                &
                self%frac_wind_z_half(self%n_meshes),           &
                self%frac_wind_xy(self%n_meshes),               &
                self%frac_wind_xy_half(self%n_meshes),          &
                self%frac_wind_oxy(self%n_meshes),              &
                self%frac_wind_oxy_half(self%n_meshes),         &
                self%dep_stencil_extent_xy(self%n_meshes),      &
                self%dep_stencil_extent_oxy(self%n_meshes),     &
                self%adv_unity_x(self%n_meshes),                &
                self%adv_unity_y(self%n_meshes),                &
                self%adv_unity_z(self%n_meshes),                &
                self%adv_unity_half_x(self%n_meshes),           &
                self%adv_unity_half_y(self%n_meshes),           &
                self%adv_unity_half_z(self%n_meshes),           &
                self%adv_detj_x(self%n_meshes),                 &
                self%adv_detj_y(self%n_meshes),                 &
                self%adv_detj_xy(self%n_meshes),                &
                self%adv_detj_x_half(self%n_meshes),            &
                self%adv_detj_y_half(self%n_meshes),            &
                self%adv_detj_xy_half(self%n_meshes),           &
                self%vert_cubic_coef(self%n_meshes,4,4),        &
                self%vert_cubic_index(self%n_meshes,4,4),       &
                self%vert_quintic_coef(self%n_meshes,2,6),      &
                self%vert_quintic_index(self%n_meshes,2,6),     &
                self%vert_linear_coef(self%n_meshes,2,2),       &
                self%horizontal_cfl_max(self%n_meshes),         &
                self%vertical_cfl_max(self%n_meshes),           &
                self%total_cfl_max(self%n_meshes) )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    ! Get mesh ID and element order
    self%mesh_ids(1) = primal_wind_n_rdef%get_mesh_id()

    ! If asked for compute objects on the shifted mesh
    if ( present(shifted_mesh ) ) then
      self%mesh_ids(2) = shifted_mesh%get_id()
      write(log_scratch_space, '(A,I4)') '... and shifted mesh: ', &
                                         shifted_mesh%get_id()
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)
    end if

    ! ======================================================================== !
    ! Create winds on shifted mesh
    if ( present(shifted_mesh) ) then
      if ( subroutine_timers ) call timer('transport.shift_wind')
      ! TODO #3008: only initialise these if they will be used
      ! For now we need to initialise them for copying the transport runtime
      call shifted_wind_n_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order_h, &
                                               element_order_v, W2) )
      call shifted_wind_np1_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order_h, &
                                               element_order_v, W2) )
      call shifted_wind_n%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order_h, &
                                               element_order_v, W2) )
      call shifted_wind_np1%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order_h, &
                                               element_order_v, W2) )

      if (num_compute_meshes == 2) then
        ! Rather than duplicating a lot of mapping code for different field types,
        ! we go by intermediate r_def fields before copying to r_tran fields
        call sample_w2_to_sh_w2_alg(shifted_wind_n_rdef,   primal_wind_n_rdef)
        call sample_w2_to_sh_w2_alg(shifted_wind_np1_rdef, primal_wind_np1_rdef)
        call copy_field(shifted_wind_n_rdef, shifted_wind_n)
        call copy_field(shifted_wind_np1_rdef, shifted_wind_np1)
      end if
      if ( subroutine_timers ) call timer('transport.shift_wind')
    end if

    ! ======================================================================== !
    ! Initialise fields
    ! TODO #3008: we should only initialise fields that we actually use
    if ( subroutine_timers ) call timer('transport.field_initialise')

    do mesh_idx = 1, num_compute_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      twod_mesh => mesh_collection%get_mesh(tmp_mesh, TWOD)
      w2_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                element_order_v, W2)
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                 element_order_v, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                 element_order_v, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                element_order_v, W3)
      w3_2d_fs => function_space_collection%get_fs(twod_mesh, element_order_h, &
                                                   element_order_v, W3)

      if (.not. self%advecting_wind(mesh_idx)%is_initialised()) then
        call self%advecting_wind(mesh_idx)%initialise( w2_fs )
        call self%horizontal_advecting_wind(mesh_idx)%initialise( w2h_fs )
        call self%vertical_advecting_wind(mesh_idx)%initialise( w2v_fs )

        call self%adjusted_v_wind(mesh_idx,1)%initialise( w2v_fs )
        call self%adjusted_v_wind(mesh_idx,2)%initialise( w2v_fs )

        ! TODO #4160: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
        if (any_splitting_vhv) then
          call self%adv_unity_half_z(mesh_idx)%initialise( w3_fs )
          call self%frac_wind_z_half(mesh_idx)%initialise( w2v_fs )
          call self%dep_dist_z_half_w2(mesh_idx)%initialise( w2v_fs )
        else
          call self%dep_dist_z_w2(mesh_idx)%initialise( w2v_fs )
          call self%frac_wind_z(mesh_idx)%initialise( w2v_fs )
          call self%adv_unity_z(mesh_idx)%initialise( w3_fs )
        end if

        if (any_splitting_hvh) then
          call self%adv_unity_half_x(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_unity_half_y(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_x_half(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_y_half(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_xy_half(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%dep_dist_xy_half_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_xy_half(mesh_idx)%initialise( w2h_fs )
          call self%dep_dist_oxy_half_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_oxy_half(mesh_idx)%initialise( w2h_fs )
        else
          call self%adv_unity_x(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_unity_y(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_x(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_y(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_xy(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%dep_dist_xy_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_xy(mesh_idx)%initialise( w2h_fs )
          call self%dep_dist_oxy_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_oxy(mesh_idx)%initialise( w2h_fs )
        end if

      end if
    end do

    if ( subroutine_timers ) call timer('transport.field_initialise')

    ! ======================================================================== !
    ! Compute auxiliary transport fields

    do mesh_idx = 1, num_compute_meshes

      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))

      !=======================================================================!
      ! Create advecting winds

      if ( mesh_idx == 1 ) then
        ! First pass, make wind_n & wind_np1 point to the primal mesh fields
        wind_n   => primal_wind_n
        wind_np1 => primal_wind_np1
      else
        ! For second pass (if needed) set wind_n & wind_np1 to point to
        ! shifted mesh versions
        wind_n   => shifted_wind_n
        wind_np1 => shifted_wind_np1
      end if

      if ( self%apply_cheap_update ) then
        ! Set advecting wind = (wind^{n+1}-wind^{n})/2
        ! For outer>2 this becomes (wind^{n+1}-wind^prev)/2
        call invoke( aX_minus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_np1, &
                                                                0.5_r_tran, wind_n) )
      else
        ! Set advecting wind = (wind^{n}+wind^{n+1})/2
        call invoke( aX_plus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_n, &
                                                               0.5_r_tran, wind_np1) )
      end if

      if (log_level() <= LOG_LEVEL_INFO .and. mesh_idx == 1) then
        call lipschitz_diag_alg(self%advecting_wind(mesh_idx), cast_dt)
      end if

      ! Split into horizontal and vertical advecting winds
      face_selector_ew => get_face_selector_ew(self%mesh_ids(mesh_idx))
      face_selector_ns => get_face_selector_ns(self%mesh_ids(mesh_idx))
      call invoke( setval_c(self%horizontal_advecting_wind(mesh_idx), 0.0_r_tran),      &
                   setval_c(self%vertical_advecting_wind(mesh_idx), 0.0_r_tran),        &
                   split_w2_field_kernel_type(self%horizontal_advecting_wind(mesh_idx), &
                                              self%vertical_advecting_wind(mesh_idx),   &
                                              self%advecting_wind(mesh_idx),            &
                                              face_selector_ew,                         &
                                              face_selector_ns) )

      ! Set number of Watkins failures to one so that substepping can be used
      ! even if Watkins is switched off
      watkins_fail = 1_i_def
      if (adjust_vhv_wind) then
        detj_at_w3 => get_detj_at_w3_r_tran(tmp_mesh%get_id())
        call watkins_fail_field%initialise( w3_2d_fs )
        call invoke( watkins_kernel_type(self%adjusted_v_wind(mesh_idx,1),     &
                                         watkins_fail_field,                   &
                                         self%advecting_wind(mesh_idx),        &
                                         cast_dt, detj_at_w3),                 &
                     X_minus_Y(self%adjusted_v_wind(mesh_idx,2),               &
                               self%vertical_advecting_wind(mesh_idx),         &
                               self%adjusted_v_wind(mesh_idx,1)) )
        call get_field_minmax(watkins_fail_field, watkins_min, watkins_fail)
      end if

      !=======================================================================!
      ! Determine if substepping is needed based on Lipschitz and
      ! estimated departure points

      if ( substep_transport /= substep_transport_off .AND. &
           watkins_fail > 0_i_def                     .AND. &
           mesh_idx == 1 ) then

        ! call substep transport algorithm and get out number_total_substeps
        call substep_transport_alg(self%number_total_substeps,     &
                                   self%advecting_wind(mesh_idx),  &
                                   cast_dt)
        ! Set new transport time step
        cast_dt = cast_dt / real(self%number_total_substeps, r_tran)

      end if

      !=======================================================================!
      ! Compute departure points

      ! Set winds for computing departure points based on cheap update flag
      if (any_vert_dep_dist .OR. any_horz_dep_dist) then
        call dep_pt_wind_n%initialise( wind_n%get_function_space() )
        call dep_pt_wind_np1%initialise( wind_np1%get_function_space() )
        if ( self%apply_cheap_update ) then
          ! Set up winds for cheap update with FFSL/SL
          call invoke( aX_minus_bY(dep_pt_wind_n, 0.5_r_tran, wind_np1,        &
                                                  0.5_r_tran, wind_n),         &
                       aX_minus_bY(dep_pt_wind_np1, 0.5_r_tran, wind_np1,      &
                                                    0.5_r_tran, wind_n) )
        else
          ! Use wind_n and wind_np1
          call invoke( setval_X(dep_pt_wind_n, wind_n), &
                       setval_X(dep_pt_wind_np1, wind_np1) )
        end if
      end if

      ! If any vertical scheme is ffsl/sl compute vertical departure points
      if (any_vert_dep_dist) then
        w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W2v)
        w2_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W2)

        call cfl_dep%initialise( w2_fs )

        ! TODO #4160: this assumes that if any_splitting_vhv=.true.
        ! then all transport uses VHV splitting
        if (any_splitting_vhv) then
          ! If any splitting is VHV then compute departure points with half time step
          half_dt = 0.5_r_tran * cast_dt
          call cfl_dep_half%initialise( w2_fs )
          call calc_vert_dep_pts( self%dep_dist_z_half_w2(mesh_idx),           &
                                  self%frac_wind_z_half(mesh_idx),             &
                                  cfl_dep_half,                                &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  half_dt,                                     &
                                  compute_cfl_dep )
          if (compute_cfl_dep) then
            ! Multiply CFL by 2 to get full CFL
            call invoke( a_times_X(cfl_dep, 2.0_r_tran, cfl_dep_half) )
          end if

        else
          ! If splitting is not VHV then compute full departure points
          call calc_vert_dep_pts( self%dep_dist_z_w2(mesh_idx),                &
                                  self%frac_wind_z(mesh_idx),                  &
                                  cfl_dep,                                     &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  cast_dt,                                     &
                                  compute_cfl_dep )

        end if

      end if

      ! If any horizontal scheme is ffsl compute horizontal departure points
      if (any_horz_dep_dist) then
        ! TODO #4160: this assumes that if any_splitting_hvh =.true.
        ! then all transport uses HVH splitting
        w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W2h)

        if (any_splitting_hvh) then
          ! If any splitting is VHV then compute departure points with half time step
          half_dt = 0.5_r_tran * cast_dt
          call calc_hori_dep_pts( self%dep_dist_xy_half_w2(mesh_idx),          &
                                  self%frac_wind_xy_half(mesh_idx),            &
                                  self%dep_stencil_extent_xy(mesh_idx),        &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  half_dt )

        else
          call calc_hori_dep_pts( self%dep_dist_xy_w2(mesh_idx),               &
                                  self%frac_wind_xy(mesh_idx),                 &
                                  self%dep_stencil_extent_xy(mesh_idx),        &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  cast_dt )

        end if
      end if

      !=======================================================================!
      ! Compute cfls for use in substepping
      if (any_scheme_mol .or. log_level() <= LOG_LEVEL_INFO) then
        if ( subroutine_timers ) call timer('transport.cfl_calculation')

        call cfl%initialise( wind_n%get_function_space() )
        call horizontal_cfl%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
        call vertical_cfl%initialise( self%vertical_advecting_wind(mesh_idx)%get_function_space() )
        call sum_horizontal_cfl%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W3) )
        call sum_cfl%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W3) )

        ! Get detj_at_w2 using wind_n
        w2_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                  element_order_v, W2)
        call detj_at_w2_transport%initialise( w2_fs )
        call select_detj_at_w2( wind_n, detj_at_w2_transport )

        call invoke( setval_X(cfl, self%advecting_wind(mesh_idx)),             &
                     inc_X_divideby_Y(cfl, detj_at_w2_transport),              &
                     inc_a_times_X(cast_dt, cfl),                              &
                     split_w2_field_kernel_type(horizontal_cfl,                &
                                                vertical_cfl,                  &
                                                cfl,                           &
                                                face_selector_ew,              &
                                                face_selector_ns) )

        select case(max_vert_cfl_calc)
        ! Calculate the maximum vertical cfl for substepping
        case(max_vert_cfl_calc_uniform)
          call get_field_minmax( vertical_cfl, v_cfl_min, v_cfl_max )
        case(max_vert_cfl_calc_dep_point)
          call hori_cfl_dep%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
          call invoke( split_w2_field_kernel_type(hori_cfl_dep,     &
                                                  vertical_cfl,     &
                                                  cfl_dep,          &
                                                  face_selector_ew, &
                                                  face_selector_ns) )
          call get_field_minmax( cfl_dep, v_cfl_min, v_cfl_max )
        case default
          write(log_scratch_space, '(A)') &
            'transport_runtime: maximum vertical CFL method not defined '
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
        end select

        ! Get the total CFL at each cell - this only works if both element orders = 0
        if (element_order_h == 0_i_def .and. element_order_v == 0_i_def) then
          call invoke( calc_max_cfl_kernel_type(sum_cfl, sum_horizontal_cfl, &
                                                horizontal_cfl, vertical_cfl) )
          call get_field_minmax( sum_horizontal_cfl, h_cfl_min, h_cfl_max )

          call get_field_minmax( sum_cfl, cfl_min, cfl_max )

          self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
          self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
          self%total_cfl_max(mesh_idx) = max(abs(cfl_max), abs(cfl_min))
        else
          call get_field_minmax( horizontal_cfl, h_cfl_min, h_cfl_max )

          self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
          self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
          self%total_cfl_max(mesh_idx) = max( self%horizontal_cfl_max(mesh_idx), &
                                              self%vertical_cfl_max(mesh_idx) )
        end if

        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum horizontal CFL ', self%horizontal_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum vertical CFL ', self%vertical_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum total CFL ', self%total_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

        if ( subroutine_timers ) call timer('transport.cfl_calculation')
      end if

      !==========================================================================!
      ! For FFSL schemes we require the transport of a unity field to get
      ! the advective FFSL transport
      if (any_scheme_ffsl) then
        call ffsl_unity_transport_alg(                                         &
                                    self%horizontal_advecting_wind(mesh_idx),  &
                                    self%vertical_advecting_wind(mesh_idx),    &
                                    cast_dt,                                   &
                                    tmp_mesh,                                  &
                                    self%adv_unity_x(mesh_idx),                &
                                    self%adv_unity_y(mesh_idx),                &
                                    self%adv_unity_z(mesh_idx),                &
                                    self%adv_unity_half_x(mesh_idx),           &
                                    self%adv_unity_half_y(mesh_idx),           &
                                    self%adv_unity_half_z(mesh_idx) )

        ! Compute volume fields ("detj") transported in each direction ---------
        ! Can't calculate the following quantities in FFSL unity alg, as they
        ! require the extended mesh remapping, which currently requires this
        ! algorithm, so creating a circular dependency
        if (any_horz_dep_dist .and. any_advective_swift) then
          detj_at_w3 => get_detj_at_w3_r_tran(tmp_mesh%get_id())
          if (any_splitting_hvh) then
            if (extended_mesh) then
              remap_depth = get_required_stencil_depth()
              call remapped_unity%initialise( self%adv_unity_half_x(mesh_idx)%get_function_space() )
              call invoke( setval_X(remapped_unity, self%adv_unity_half_x(mesh_idx)) )
              call remap_on_extended_mesh(self%adv_unity_half_x(mesh_idx),     &
                                          remapped_unity,                      &
                                          self%rho_monotone_remap,             &
                                          self%rho_enforce_minvalue,           &
                                          self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_x_half(mesh_idx),     &
                                        self%adv_unity_half_x(mesh_idx), detj_at_w3)

              call invoke( setval_X(remapped_unity, self%adv_unity_half_y(mesh_idx)) )
              call remap_on_extended_mesh(self%adv_unity_half_y(mesh_idx),     &
                                          remapped_unity,                      &
                                          self%rho_monotone_remap,             &
                                          self%rho_enforce_minvalue,           &
                                          self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_y_half(mesh_idx),     &
                                         self%adv_unity_half_y(mesh_idx), detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_x_half(mesh_idx),         &
                                     self%adv_unity_half_x(mesh_idx),          &
                                     detj_at_w3),                              &
                           X_times_Y(self%adv_detj_y_half(mesh_idx),         &
                                     self%adv_unity_half_y(mesh_idx),          &
                                     detj_at_w3) )
            end if
          else
            if (extended_mesh) then
              remap_depth = get_required_stencil_depth()
              call remapped_unity%initialise( self%adv_unity_x(mesh_idx)%get_function_space() )
              call invoke( setval_X(remapped_unity, self%adv_unity_x(mesh_idx)) )
              call remap_on_extended_mesh(self%adv_unity_x(mesh_idx),          &
                                          remapped_unity,                      &
                                          self%rho_monotone_remap,             &
                                          self%rho_enforce_minvalue,           &
                                          self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_x(mesh_idx),            &
                                         self%adv_unity_x(mesh_idx), detj_at_w3)

              call invoke( setval_X(remapped_unity, self%adv_unity_y(mesh_idx)) )
              call remap_on_extended_mesh(self%adv_unity_y(mesh_idx),          &
                                          remapped_unity,                      &
                                          self%rho_monotone_remap,             &
                                          self%rho_enforce_minvalue,           &
                                          self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_y(mesh_idx),            &
                                         self%adv_unity_y(mesh_idx), detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_x(mesh_idx),                &
                                     self%adv_unity_x(mesh_idx),               &
                                     detj_at_w3),                              &
                           X_times_Y(self%adv_detj_y(mesh_idx),                &
                                     self%adv_unity_y(mesh_idx),               &
                                     detj_at_w3) )
            end if
          end if
          ! Compute quantities for outer SWIFT step
          call adv_unity_xy%initialise( detj_at_w3%get_function_space() )
          if (any_splitting_hvh) then
            call ffsl_unity_swift_alg(                                         &
                                    adv_unity_xy,                              &
                                    self%dep_dist_oxy_half_w2(mesh_idx),       &
                                    self%frac_wind_oxy_half(mesh_idx),         &
                                    self%dep_stencil_extent_oxy(mesh_idx),     &
                                    self%horizontal_advecting_wind(mesh_idx),  &
                                    self%adv_detj_x_half(mesh_idx),            &
                                    self%adv_detj_y_half(mesh_idx),            &
                                    dep_pt_stencil_extent,                     &
                                    half_dt)
          else
            call ffsl_unity_swift_alg(                                         &
                                    adv_unity_xy,                              &
                                    self%dep_dist_oxy_w2(mesh_idx),            &
                                    self%frac_wind_oxy(mesh_idx),              &
                                    self%dep_stencil_extent_oxy(mesh_idx),     &
                                    self%horizontal_advecting_wind(mesh_idx),  &
                                    self%adv_detj_x(mesh_idx),                 &
                                    self%adv_detj_y(mesh_idx),                 &
                                    dep_pt_stencil_extent,                     &
                                    cast_dt)
          end if
          ! Compute updated volumes (adv_detj_xy)
          if (any_splitting_hvh) then
            if (extended_mesh) then
              remap_depth = self%dep_stencil_extent_oxy(mesh_idx) &
                          + 2_i_def + max(ffsl_inner_order, ffsl_outer_order)
              call remap_on_extended_mesh(remapped_unity, adv_unity_xy,        &
                                          self%rho_monotone_remap,             &
                                          self%rho_enforce_minvalue,           &
                                          self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_xy_half(mesh_idx),      &
                                         remapped_unity, detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_xy_half(mesh_idx),          &
                                     adv_unity_xy, detj_at_w3) )
            end if
          else
            if (extended_mesh) then
              remap_depth = self%dep_stencil_extent_oxy(mesh_idx) &
                          + 2_i_def + max(ffsl_inner_order, ffsl_outer_order)
              call remap_on_extended_mesh(remapped_unity, adv_unity_xy,        &
                                          self%rho_monotone_remap,             &
                                          self%rho_enforce_minvalue,           &
                                          self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_xy(mesh_idx),           &
                                         remapped_unity, detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_xy(mesh_idx),               &
                                     adv_unity_xy, detj_at_w3) )
            end if
          end if
        end if
      end if

      !==========================================================================!
      ! Compute vertical semi-Lagrangian interpolation coefficients
      if ( any_vert_scheme_sl .OR. self%advective_first_outer ) then
        ! Initialise coefficient fields with array index
        ! (mesh,function_space,coefficient_number)
        ! for the primal mesh only unless SLICE is used
        if ( subroutine_timers ) call timer('transport.calc_sl_coeffs')

        if ( mesh_idx == 1 .OR. any_scheme_slice ) then

          ! Get W3 and Wtheta function space
          w3_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                    element_order_v, W3)
          wt_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                    element_order_v, Wtheta)

          ! Initialise linear coefficients
          if (.not. self%vert_linear_coef(mesh_idx,1,1)%is_initialised()) then
            do i_coef=1, 2
              call self%vert_linear_coef(mesh_idx,1,i_coef)%initialise( vector_space=w3_fs )
              call self%vert_linear_coef(mesh_idx,2,i_coef)%initialise( vector_space=wt_fs )
            end do
          end if

          ! TODO: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
          if (any_splitting_vhv) then
            vhv_split_sl = .true.
          else
            vhv_split_sl = .false.
          end if

          if ( any_reversible_sl .OR. self%advective_first_outer .OR. &
               vertical_sl_order == vertical_sl_order_cubic_hermite ) then
            ! Compute cubic-Hermite coefficients (as part of vert_cubic_coef/index)
            hermite_sl = .true.

            if (.not. self%vert_cubic_coef(mesh_idx,3,1)%is_initialised()) then
              do i_coef=1, 4
                call self%vert_cubic_coef(mesh_idx,3,i_coef)%initialise(  vector_space=w3_fs )
                call self%vert_cubic_index(mesh_idx,3,i_coef)%initialise( vector_space=w3_fs )
                call self%vert_cubic_coef(mesh_idx,4,i_coef)%initialise(  vector_space=wt_fs )
                call self%vert_cubic_index(mesh_idx,4,i_coef)%initialise( vector_space=wt_fs )
              end do
            end if

            call compute_vert_cubic_coefficients_alg( self%vert_cubic_coef(mesh_idx,3,1:4),  &
                                                      self%vert_cubic_index(mesh_idx,3,1:4), &
                                                      self%vert_linear_coef(mesh_idx,1,1:2), &
                                                      self%vert_cubic_coef(mesh_idx,4,1:4),  &
                                                      self%vert_cubic_index(mesh_idx,4,1:4), &
                                                      self%vert_linear_coef(mesh_idx,2,1:2), &
                                                      self%dep_dist_z_w2(mesh_idx),      &
                                                      self%dep_dist_z_half_w2(mesh_idx), &
                                                      hermite_sl, vhv_split_sl )

          end if

          if ( vertical_sl_order == vertical_sl_order_quintic ) then
            ! Initialise and compute quintic coefficients
            if (.not. self%vert_quintic_coef(mesh_idx,1,1)%is_initialised()) then
              do i_coef=1, 6
                call self%vert_quintic_coef(mesh_idx,1,i_coef)%initialise(  vector_space=w3_fs )
                call self%vert_quintic_index(mesh_idx,1,i_coef)%initialise( vector_space=w3_fs )
                call self%vert_quintic_coef(mesh_idx,2,i_coef)%initialise(  vector_space=wt_fs )
                call self%vert_quintic_index(mesh_idx,2,i_coef)%initialise( vector_space=wt_fs )
              end do
            end if

            call compute_vert_quintic_coefficients_alg( self%vert_quintic_coef(mesh_idx,1,1:6),  &
                                                        self%vert_quintic_index(mesh_idx,1,1:6), &
                                                        self%vert_linear_coef(mesh_idx,1,1:2),   &
                                                        self%vert_quintic_coef(mesh_idx,1,1:6),  &
                                                        self%vert_quintic_index(mesh_idx,1,1:6), &
                                                        self%vert_linear_coef(mesh_idx,1,1:2),   &
                                                        self%dep_dist_z_w2(mesh_idx),            &
                                                        self%dep_dist_z_half_w2(mesh_idx),       &
                                                        vhv_split_sl )
          else
            ! Initialise and compute cubic coefficients
            if (.not. self%vert_cubic_coef(mesh_idx,1,1)%is_initialised()) then
              do i_coef=1, 4
                call self%vert_cubic_coef(mesh_idx,1,i_coef)%initialise(  vector_space=w3_fs )
                call self%vert_cubic_index(mesh_idx,1,i_coef)%initialise( vector_space=w3_fs )
                call self%vert_cubic_coef(mesh_idx,2,i_coef)%initialise(  vector_space=wt_fs )
                call self%vert_cubic_index(mesh_idx,2,i_coef)%initialise( vector_space=wt_fs )
              end do
            end if

            hermite_sl = .false.
            call compute_vert_cubic_coefficients_alg( self%vert_cubic_coef(mesh_idx,1,1:4),   &
                                                      self%vert_cubic_index(mesh_idx,1,1:4),  &
                                                      self%vert_linear_coef(mesh_idx,1,1:2),  &
                                                      self%vert_cubic_coef(mesh_idx,2,1:4),   &
                                                      self%vert_cubic_index(mesh_idx,2,1:4),  &
                                                      self%vert_linear_coef(mesh_idx,2,1:2),  &
                                                      self%dep_dist_z_w2(mesh_idx),           &
                                                      self%dep_dist_z_half_w2(mesh_idx),      &
                                                      hermite_sl, vhv_split_sl )
          end if

          nullify( w3_fs, wt_fs )

        end if

        if ( subroutine_timers ) call timer('transport.calc_sl_coeffs')

      end if ! vertical SL interpolation coefficients

    end do ! loop over meshes

    !==========================================================================!

    ! Allocate arrays for dry fields
    if ( .not. allocated( self%rho_d ) ) then
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
      ! We allocate fields for the shifted mesh here
      n_meshes = self%n_meshes
      n_steps = self%num_dry_steps
      n_steps_with_substep = self%number_total_substeps*n_steps
      np1_steps_with_substep = self%number_total_substeps*(n_steps+1)
      allocate( self%rho_d(n_meshes, np1_steps_with_substep),                   &
                self%dry_mass(n_meshes, np1_steps_with_substep),                &
                self%dry_mass_ffsl_x(n_meshes, n_steps_with_substep),           &
                self%dry_mass_ffsl_y(n_meshes, n_steps_with_substep),           &
                self%total_rho_d(n_meshes, n_steps+1),                          &
                self%total_dry_mass(n_meshes, n_steps+1),                       &
                self%total_dry_mass_ffsl_x(n_meshes, n_steps),                  &
                self%total_dry_mass_ffsl_y(n_meshes, n_steps),                  &
                self%detj_unity(n_meshes, n_steps+1),                           &
                self%detj_unity_x(n_meshes, n_steps),                           &
                self%detj_unity_y(n_meshes, n_steps),                           &
                self%flux(n_meshes, n_steps-1),                                 &
                self%dry_flux(n_meshes, n_steps_with_substep),                  &
                self%total_dry_flux(n_meshes, n_steps),                         &
                self%tracer_dep_dist_ixy(n_meshes, n_steps_with_substep),       &
                self%tracer_dep_dist_oxy(n_meshes, n_steps_with_substep),       &
                self%tracer_dep_dist_z(n_meshes, n_steps_with_substep),         &
                self%unity_dep_dist_ixy(n_meshes, n_steps),                     &
                self%unity_dep_dist_oxy(n_meshes, n_steps),                     &
                self%unity_dep_dist_z(n_meshes, n_steps),                       &
                self%unity_frac_wind_ixy(n_meshes, n_steps),                    &
                self%unity_frac_wind_oxy(n_meshes, n_steps),                    &
                self%unity_frac_wind_z(n_meshes, n_steps),                      &
                self%dry_frac_flux_z(n_meshes, n_steps_with_substep),           &
                self%dry_frac_flux_ixy(n_meshes, n_steps_with_substep),         &
                self%dry_frac_flux_oxy(n_meshes, n_steps_with_substep),         &
                self%tracer_stencil_extent_ixy(n_meshes, n_steps_with_substep), &
                self%tracer_stencil_extent_oxy(n_meshes, n_steps_with_substep), &
                self%unity_stencil_extent_ixy(n_meshes, n_steps),               &
                self%unity_stencil_extent_oxy(n_meshes, n_steps)                &
              )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    if ( substep_transport == substep_transport_adaptive ) then
      ! Need to deallocate and reallocate the fields that depend on substep
      ! number as adaptive substep may change this between time steps
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
      deallocate( self%rho_d,                     &
                  self%dry_mass,                  &
                  self%dry_mass_ffsl_x,           &
                  self%dry_mass_ffsl_y,           &
                  self%dry_flux,                  &
                  self%tracer_dep_dist_ixy,       &
                  self%tracer_dep_dist_oxy,       &
                  self%tracer_dep_dist_z,         &
                  self%dry_frac_flux_z,           &
                  self%dry_frac_flux_ixy,         &
                  self%dry_frac_flux_oxy,         &
                  self%tracer_stencil_extent_ixy, &
                  self%tracer_stencil_extent_oxy  &
                )
      n_meshes = self%n_meshes
      n_steps = self%num_dry_steps
      n_steps_with_substep = self%number_total_substeps*n_steps
      np1_steps_with_substep = self%number_total_substeps*(n_steps+1)
      allocate( self%rho_d(n_meshes, np1_steps_with_substep),                   &
                self%dry_mass(n_meshes, np1_steps_with_substep),                &
                self%dry_mass_ffsl_x(n_meshes, n_steps_with_substep),           &
                self%dry_mass_ffsl_y(n_meshes, n_steps_with_substep),           &
                self%dry_flux(n_meshes, n_steps_with_substep),                  &
                self%tracer_dep_dist_ixy(n_meshes, n_steps_with_substep),       &
                self%tracer_dep_dist_oxy(n_meshes, n_steps_with_substep),       &
                self%tracer_dep_dist_z(n_meshes, n_steps_with_substep),         &
                self%dry_frac_flux_z(n_meshes, n_steps_with_substep),           &
                self%dry_frac_flux_ixy(n_meshes, n_steps_with_substep),         &
                self%dry_frac_flux_oxy(n_meshes, n_steps_with_substep),         &
                self%tracer_stencil_extent_ixy(n_meshes, n_steps_with_substep), &
                self%tracer_stencil_extent_oxy(n_meshes, n_steps_with_substep)  &
              )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    ! Set dry density from start of transport step
    if (present(rho_d_n_rdef)) then
      call rho_d_n%initialise( rho_d_n_rdef%get_function_space() )
      call copy_field(rho_d_n_rdef, rho_d_n)
      call self%set_rho_d(rho_d_n, 1)
    end if

    ! ------------------------------------------------------------------------ !
    ! Now compute transport by unity terms
    ! ------------------------------------------------------------------------ !
    if (ffsl_unity_3d .and. any_scheme_split_ffsl) then
      do mesh_idx = 1, num_compute_meshes
        tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
        w3_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                  element_order_v, W3)
        w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W2h)
        w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order_h, &
                                                   element_order_v, W2v)
        detj_at_w3 => get_detj_at_w3_r_tran(tmp_mesh%get_id())
        panel_id => get_panel_id(tmp_mesh%get_id())

        ! Set first unity and volume fields
        call unity_field%initialise( w3_fs )
        call increment%initialise( w3_fs )
        call unity_x%initialise( w3_fs )
        call unity_y%initialise( w3_fs )
        call detj_copy%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )
        call hori_wind_dt%initialise( w2h_fs )
        call vert_wind_dt%initialise( w2v_fs )

        call self%detj_unity(mesh_idx, 1)%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )

        call invoke( setval_X(self%detj_unity(mesh_idx, 1), detj_at_w3) )

        ! Loop through steps
        do step = 1, self%num_dry_steps
          step_dt = self%splitting_fraction(step)*cast_dt
          call self%detj_unity(mesh_idx, step+1)%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )

          ! Depending on direction, and whether using null transport
          ! NULL TRANSPORT -----------------------------------------------------
          if (self%direction_w2_fs(step) == W2H .and.                          &
              horizontal_method(self%dry_config) == split_method_null) then

            call self%detj_unity_x(mesh_idx, step)%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )
            call self%detj_unity_y(mesh_idx, step)%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )
            call self%unity_dep_dist_ixy(mesh_idx, step)%initialise( w2h_fs )
            call self%unity_dep_dist_oxy(mesh_idx, step)%initialise( w2h_fs )
            call self%unity_frac_wind_ixy(mesh_idx, step)%initialise( w2h_fs )
            call self%unity_frac_wind_oxy(mesh_idx, step)%initialise( w2h_fs )

            call invoke( setval_X(self%detj_unity(mesh_idx, step+1),           &
                                  self%detj_unity(mesh_idx, step)),            &
                         setval_X(self%detj_unity_x(mesh_idx, step),           &
                                  self%detj_unity(mesh_idx, step)),            &
                         setval_X(self%detj_unity_y(mesh_idx, step),           &
                                  self%detj_unity(mesh_idx, step)),            &
                         setval_c(self%unity_dep_dist_ixy(mesh_idx, step),     &
                                  0.0_r_tran),                                 &
                         setval_c(self%unity_frac_wind_ixy(mesh_idx, step),    &
                                  0.0_r_tran),                                 &
                         setval_c(self%unity_dep_dist_oxy(mesh_idx, step),     &
                                  0.0_r_tran),                                 &
                         setval_c(self%unity_frac_wind_oxy(mesh_idx, step),    &
                                  0.0_r_tran) )

            self%unity_stencil_extent_ixy(mesh_idx, step) = 1_i_def
            self%unity_stencil_extent_oxy(mesh_idx, step) = 1_i_def

          else if (self%direction_w2_fs(step) == W2V .and.                     &
                   vertical_method(self%dry_config) == split_method_null) then

            call self%unity_dep_dist_z(mesh_idx, step)%initialise( w2v_fs )
            call self%unity_frac_wind_z(mesh_idx, step)%initialise( w2v_fs )

            call invoke( setval_X(self%detj_unity(mesh_idx, step+1),           &
                                  self%detj_unity(mesh_idx, step)),            &
                         setval_c(self%unity_dep_dist_z(mesh_idx, step),       &
                                  0.0_r_tran),                                 &
                         setval_c(self%unity_frac_wind_z(mesh_idx, step),      &
                                  0.0_r_tran) )

          ! HORIZONTAL TRANSPORT -----------------------------------------------
          else if (self%direction_w2_fs(step) == W2H) then

            call self%detj_unity_x(mesh_idx, step)%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )
            call self%detj_unity_y(mesh_idx, step)%initialise( w3_fs, halo_depth=tmp_mesh%get_halo_depth() )
            call self%unity_dep_dist_ixy(mesh_idx, step)%initialise( w2h_fs )
            call self%unity_dep_dist_oxy(mesh_idx, step)%initialise( w2h_fs )
            call self%unity_frac_wind_ixy(mesh_idx, step)%initialise( w2h_fs )
            call self%unity_frac_wind_oxy(mesh_idx, step)%initialise( w2h_fs )
            hori_wind => self%get_directional_advecting_wind(tmp_mesh%get_id(), direction_h)

            ! Compute updated volumes corresponding to advection of unity
            call invoke( fv_difference_x_kernel_type(increment, hori_wind),    &
                         X_minus_bY(self%detj_unity_x(mesh_idx, step),         &
                                    self%detj_unity(mesh_idx, step),           &
                                    step_dt, increment),                       &
                         fv_difference_y_kernel_type(increment, hori_wind),    &
                         X_minus_bY(self%detj_unity_y(mesh_idx, step),         &
                                    self%detj_unity(mesh_idx, step),           &
                                    step_dt, increment),                       &
                         X_minus_bY(self%detj_unity(mesh_idx, step+1),         &
                                    self%detj_unity_x(mesh_idx, step),         &
                                    step_dt, increment) )

            ! Swap the halo values of adv_detj_x and adv_detj_y here
            if (topology == topology_fully_periodic .AND. geometry == geometry_spherical) then
              halo_depth = tmp_mesh%get_halo_depth()
              call invoke( ffsl_panel_swap_kernel_type(self%detj_unity_x(mesh_idx, step), &
                                                       self%detj_unity_y(mesh_idx, step), &
                                                       panel_id, halo_depth ) )
            end if

            ! Compute fractional wind and departure points from transported unity
            call invoke( setval_X(detj_copy, self%detj_unity(mesh_idx, step)), &
                         a_times_X(hori_wind_dt, step_dt, hori_wind) )
            call calc_ffsl_hori_dep_pts(                                       &
                                self%unity_dep_dist_ixy(mesh_idx, step),       &
                                self%unity_frac_wind_ixy(mesh_idx, step),      &
                                self%unity_stencil_extent_ixy(mesh_idx, step), &
                                hori_wind_dt,                                  &
                                self%detj_unity(mesh_idx, step),               &
                                detj_copy                                      &
            )
            call calc_ffsl_hori_dep_pts(                                       &
                                self%unity_dep_dist_oxy(mesh_idx, step),       &
                                self%unity_frac_wind_oxy(mesh_idx, step),      &
                                self%unity_stencil_extent_oxy(mesh_idx, step), &
                                hori_wind_dt,                                  &
                                self%detj_unity_y(mesh_idx, step),             &
                                self%detj_unity_x(mesh_idx, step)              &
            )

          ! VERTICAL TRANSPORT -------------------------------------------------
          else if (self%direction_w2_fs(step) == W2V) then

            call self%unity_dep_dist_z(mesh_idx, step)%initialise( w2v_fs )
            call self%unity_frac_wind_z(mesh_idx, step)%initialise( w2v_fs )

            if (adjust_vhv_wind) then
              vert_wind => self%get_adjusted_v_wind(tmp_mesh%get_id(), step)
              ! Wind already includes fractional factor, so need to just use
              ! standard dt here (instead of dt*fractional factor)
              step_dt = cast_dt
            else
              vert_wind => self%get_directional_advecting_wind(tmp_mesh%get_id(), direction_v)
            end if

            call invoke( fv_difference_z_kernel_type(increment, vert_wind),    &
                         X_minus_bY(self%detj_unity(mesh_idx, step+1),         &
                                    self%detj_unity(mesh_idx, step),           &
                                    step_dt, increment),                       &
                         a_times_X(vert_wind_dt, step_dt, vert_wind),          &
                         vert_dep_dist_ffsl_kernel_type(                       &
                                  self%unity_dep_dist_z(mesh_idx, step),       &
                                  self%unity_frac_wind_z(mesh_idx, step),      &
                                  vert_wind_dt,                                &
                                  self%detj_unity(mesh_idx, step)) )

          else
            call log_event('Direction for unity transport not implemented', LOG_LEVEL_ERROR)
          end if
        end do
      end do
    end if

    ! Set step and sub step counters to be 1
    self%tracer_step_ctr = 1
    self%substep_total_ctr = 1

    nullify(mesh, local_mesh, w2_fs, w3_fs, tmp_mesh, w2h_fs, w2v_fs, &
            w3_2d_fs, face_selector_ew, face_selector_ns)

    if ( subroutine_timers ) call timer('transport.runtime_init')

  end subroutine transport_runtime_initialiser

  !> Finalizer for the transport runtime
  !> @param [in,out] self The transport runtime object
  subroutine destroy_transport_runtime(self)
    implicit none
    type(transport_runtime_type), intent(inout) :: self

    if ( allocated( self%mesh_ids ) )                  deallocate( self%mesh_ids )
    if ( allocated( self%advecting_wind ) )            deallocate( self%advecting_wind )
    if ( allocated( self%horizontal_advecting_wind ) ) deallocate( self%horizontal_advecting_wind )
    if ( allocated( self%vertical_advecting_wind ) )   deallocate( self%vertical_advecting_wind )
    if ( allocated( self%adjusted_v_wind ) )           deallocate( self%adjusted_v_wind )
    if ( allocated( self%dep_dist_xy_w2 ) )            deallocate( self%dep_dist_xy_w2 )
    if ( allocated( self%dep_dist_xy_half_w2 ) )       deallocate( self%dep_dist_xy_half_w2 )
    if ( allocated( self%dep_dist_oxy_w2 ) )           deallocate( self%dep_dist_oxy_w2 )
    if ( allocated( self%dep_dist_oxy_half_w2 ) )      deallocate( self%dep_dist_oxy_half_w2 )
    if ( allocated( self%dep_dist_z_w2 ) )             deallocate( self%dep_dist_z_w2 )
    if ( allocated( self%frac_wind_z ) )               deallocate( self%frac_wind_z )
    if ( allocated( self%frac_wind_z_half ) )          deallocate( self%frac_wind_z_half )
    if ( allocated( self%frac_wind_xy ) )              deallocate( self%frac_wind_xy )
    if ( allocated( self%frac_wind_xy_half ) )         deallocate( self%frac_wind_xy_half )
    if ( allocated( self%frac_wind_oxy ) )             deallocate( self%frac_wind_oxy )
    if ( allocated( self%frac_wind_oxy_half ) )        deallocate( self%frac_wind_oxy_half )
    if ( allocated( self%adv_unity_x ) )               deallocate( self%adv_unity_x )
    if ( allocated( self%adv_unity_y ) )               deallocate( self%adv_unity_y )
    if ( allocated( self%adv_unity_z ) )               deallocate( self%adv_unity_z )
    if ( allocated( self%adv_unity_half_x ) )          deallocate( self%adv_unity_half_x )
    if ( allocated( self%adv_unity_half_y ) )          deallocate( self%adv_unity_half_y )
    if ( allocated( self%adv_unity_half_z ) )          deallocate( self%adv_unity_half_z )
    if ( allocated( self%adv_detj_x ) )                deallocate( self%adv_detj_x )
    if ( allocated( self%adv_detj_y ) )                deallocate( self%adv_detj_y )
    if ( allocated( self%adv_detj_xy ) )               deallocate( self%adv_detj_xy )
    if ( allocated( self%adv_detj_x_half ) )           deallocate( self%adv_detj_x_half )
    if ( allocated( self%adv_detj_y_half ) )           deallocate( self%adv_detj_y_half )
    if ( allocated( self%adv_detj_xy_half ) )          deallocate( self%adv_detj_xy_half )
    if ( allocated( self%vert_cubic_coef ) )           deallocate( self%vert_cubic_coef )
    if ( allocated( self%vert_cubic_index ) )          deallocate( self%vert_cubic_index )
    if ( allocated( self%vert_quintic_coef ) )         deallocate( self%vert_quintic_coef )
    if ( allocated( self%vert_quintic_index ) )        deallocate( self%vert_quintic_index )
    if ( allocated( self%vert_linear_coef ) )          deallocate( self%vert_linear_coef )
    if ( allocated( self%rho_d ) )                     deallocate( self%rho_d )
    if ( allocated( self%dry_mass ) )                  deallocate( self%dry_mass )
    if ( allocated( self%dry_mass_ffsl_x ) )           deallocate( self%dry_mass_ffsl_x )
    if ( allocated( self%dry_mass_ffsl_y ) )           deallocate( self%dry_mass_ffsl_y )
    if ( allocated( self%total_rho_d ) )               deallocate( self%total_rho_d )
    if ( allocated( self%total_dry_mass ) )            deallocate( self%total_dry_mass )
    if ( allocated( self%total_dry_mass_ffsl_x ) )     deallocate( self%total_dry_mass_ffsl_x )
    if ( allocated( self%total_dry_mass_ffsl_y ) )     deallocate( self%total_dry_mass_ffsl_y )
    if ( allocated( self%flux ) )                      deallocate( self%flux )
    if ( allocated( self%dry_flux ) )                  deallocate( self%dry_flux )
    if ( allocated( self%total_dry_flux ) )            deallocate( self%total_dry_flux )
    if ( allocated( self%horizontal_cfl_max ) )        deallocate( self%horizontal_cfl_max )
    if ( allocated( self%vertical_cfl_max ) )          deallocate( self%vertical_cfl_max )
    if ( allocated( self%total_cfl_max ) )             deallocate( self%total_cfl_max )
    if ( allocated( self%tracer_dep_dist_z ) )         deallocate( self%tracer_dep_dist_z )
    if ( allocated( self%tracer_dep_dist_ixy ) )       deallocate( self%tracer_dep_dist_ixy )
    if ( allocated( self%tracer_dep_dist_oxy ) )       deallocate( self%tracer_dep_dist_oxy )
    if ( allocated( self%dry_frac_flux_ixy ) )         deallocate( self%dry_frac_flux_ixy )
    if ( allocated( self%dry_frac_flux_oxy ) )         deallocate( self%dry_frac_flux_oxy )
    if ( allocated( self%dry_frac_flux_z ) )           deallocate( self%dry_frac_flux_z )
    if ( allocated( self%tracer_stencil_extent_ixy ) ) deallocate( self%tracer_stencil_extent_ixy )
    if ( allocated( self%tracer_stencil_extent_oxy ) ) deallocate( self%tracer_stencil_extent_oxy )
    if ( allocated( self%dep_stencil_extent_xy ) )     deallocate( self%dep_stencil_extent_xy )
    if ( allocated( self%dep_stencil_extent_oxy ) )    deallocate( self%dep_stencil_extent_oxy )
    if ( allocated( self%unity_dep_dist_z ) )          deallocate( self%unity_dep_dist_z )
    if ( allocated( self%unity_dep_dist_ixy ) )        deallocate( self%unity_dep_dist_ixy )
    if ( allocated( self%unity_dep_dist_oxy ) )        deallocate( self%unity_dep_dist_oxy )
    if ( allocated( self%unity_frac_wind_ixy ) )       deallocate( self%unity_frac_wind_ixy )
    if ( allocated( self%unity_frac_wind_oxy ) )       deallocate( self%unity_frac_wind_oxy )
    if ( allocated( self%unity_frac_wind_z ) )         deallocate( self%unity_frac_wind_z )
    if ( allocated( self%unity_stencil_extent_ixy ) )  deallocate( self%unity_stencil_extent_ixy )
    if ( allocated( self%unity_stencil_extent_oxy ) )  deallocate( self%unity_stencil_extent_oxy )
    if ( allocated( self%detj_unity ) )                deallocate( self%detj_unity )
    if ( allocated( self%detj_unity_x ) )              deallocate( self%detj_unity_x )
    if ( allocated( self%detj_unity_y ) )              deallocate( self%detj_unity_y )

  end subroutine destroy_transport_runtime

! ============================================================================ !
! SETTERS
! ============================================================================ !

  !> @brief Sets the dry flux for use in consistent tracer transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in]     dry_flux  Flux field used to transport dry density
  !> @param[in]     step      The step to store the flux for.
  !!                          Note that if there is substepping then this
  !!                          argument has the form
  !!                          (substep-1) * n_step + step_number
  subroutine set_dry_flux(self, dry_flux, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: dry_flux
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),  pointer :: prime_extrusion_mesh => null()

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => dry_flux%get_mesh()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    call dry_flux%copy_field_properties(self%dry_flux(1,step))
    call invoke( setval_X(self%dry_flux(1,step), dry_flux) )

    ! If we are using the cheap update for transport then we need to
    ! save the total dry flux (from all outer semi-implicit iterations)
    ! for consistent transport
    if (self%cheap_update_flag) then
      if (self%apply_cheap_update) then
        ! Subsequent outer transport step using cheap update
        ! so increment total_dry_flux
        call invoke( inc_X_plus_Y(self%total_dry_flux(1,step), self%dry_flux(1,step)) )
      else
        ! First outer transport step using cheap update
        ! so initialise total_dry_flux
        call self%dry_flux(1,step)%copy_field_properties(self%total_dry_flux(1,step))
        call invoke( setval_X(self%total_dry_flux(1,step), self%dry_flux(1,step)) )
      end if
    end if

    nullify( prime_extrusion_mesh )

  end subroutine set_dry_flux

  !> @brief Sets a dry density field to use in tracer transport, and computes
  !!        the corresponding mass field
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for.
  !!                            Note that if there is substepping then this
  !!                            argument has the form
  !!                            (substep-1) * (n_step+1) + step_number
  subroutine set_rho_d(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    logical(kind=l_def)              :: next_step_hori
    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    type(r_tran_field_type), pointer :: detj => null()
    integer(kind=i_def)              :: w2_fs_idx
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()
    detj => get_detj_at_w3_r_tran(prime_extrusion_mesh%get_id())

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    w2_fs_idx = self%direction_w2_fs(step)
    next_step_hori = (step < self%get_num_dry_steps() + 1 .and. &
                      w2_fs_idx == W2H .or. w2_fs_idx == W2)

    if (.not. self%dry_mass(1,step)%is_initialised()) then
      call self%dry_mass(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                             halo_depth = get_required_stencil_depth() )
      call self%rho_d(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                          halo_depth = get_required_stencil_depth() )
    end if

    if (extended_mesh .and. next_step_hori) then
      if ( check_any_horizontal_method_mol() ) then
        remap_depth = get_required_stencil_depth()
      else
        ! For consistent transport the cfl may be slightly higher than expected
        ! due to using the dry mass flux to compute departure points, therefore
        ! an extra + 1 is added to remap_depth for safety
        remap_depth = self%get_dep_stencil_extent_xy(self%mesh_ids(1), .false.) &
                    + 2_i_def + max(ffsl_inner_order, ffsl_outer_order)
      end if
      call remap_on_extended_mesh(self%rho_d(1,step), rho_d, &
                                  self%rho_monotone_remap,   &
                                  self%rho_enforce_minvalue, &
                                  self%rho_minvalue, remap_depth)
      ! Now compute mass field
      ! @todo #4302: replace this with redundant computation
      call invoke_deep_X_times_Y(self%dry_mass(1,step), &
                                 self%rho_d(1,step),    &
                                 detj)

    else
      call invoke( setval_X(self%rho_d(1,step), rho_d), &
                   X_times_Y(self%dry_mass(1,step), rho_d, detj) )
    end if

    nullify( prime_extrusion_mesh, detj )

  end subroutine set_rho_d

  !> @brief Sets a dry density field to use in FFSL tracer transport, and
  !!        computes the corresponding mass field. This should be the dry
  !!        density field from a horizontal x step
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for.
  !!                            Note that if there is substepping then this
  !!                            argument has the form
  !!                            (substep-1) * n_step + step_number
  subroutine set_rho_d_ffsl_x(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    type(r_tran_field_type), pointer :: detj => null()
    type(r_tran_field_type)          :: rho_d_ffsl_x
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()
    detj => get_detj_at_w3_r_tran(prime_extrusion_mesh%get_id())

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    if (.not. self%dry_mass_ffsl_x(1,step)%is_initialised()) then
      call self%dry_mass_ffsl_x(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                                    halo_depth = get_required_stencil_depth() )
    end if

    if (extended_mesh) then
      ! First remap rho
      ! As this will be used for computing departure distances, compute to
      ! full stencil depth
      remap_depth = get_required_stencil_depth()
      call remap_on_extended_mesh(rho_d_ffsl_x, rho_d,              &
                                  self%rho_monotone_remap,          &
                                  self%rho_enforce_minvalue,        &
                                  self%rho_minvalue, remap_depth)

      ! Now compute mass field
      ! @todo #4302: replace this with redundant computation
      call invoke_deep_X_times_Y(self%dry_mass_ffsl_x(1,step), &
                                 rho_d_ffsl_x, detj)
    else
      call invoke( X_times_Y(self%dry_mass_ffsl_x(1,step), rho_d, detj) )
    end if

    nullify( prime_extrusion_mesh, detj )

  end subroutine set_rho_d_ffsl_x

  !> @brief Sets a dry density field to use in FFSL tracer transport, and
  !!        computes the corresponding mass field. This should be the dry
  !!        density field from a horizontal y step
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for.
  !!                            Note that if there is substepping then this
  !!                            argument has the form
  !!                            (substep-1) * n_step + step_number
  subroutine set_rho_d_ffsl_y(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    type(r_tran_field_type), pointer :: detj => null()
    type(r_tran_field_type)          :: rho_d_ffsl_y
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()
    detj => get_detj_at_w3_r_tran(prime_extrusion_mesh%get_id())

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    if (.not. self%dry_mass_ffsl_y(1,step)%is_initialised()) then
      call self%dry_mass_ffsl_y(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                                    halo_depth = get_required_stencil_depth() )
    end if

    if (extended_mesh) then
      ! First remap rho
      ! As this will be used for computing departure distances, compute to
      ! full stencil depth
      remap_depth = get_required_stencil_depth()
      call remap_on_extended_mesh(rho_d_ffsl_y, rho_d,              &
                                  self%rho_monotone_remap,          &
                                  self%rho_enforce_minvalue,        &
                                  self%rho_minvalue, remap_depth)
      ! Now compute mass field
      ! @todo #4302: replace this with redundant computation
      call invoke_deep_X_times_Y(self%dry_mass_ffsl_y(1,step), &
                                 rho_d_ffsl_y, detj)
    else
      call invoke( X_times_Y(self%dry_mass_ffsl_y(1,step), rho_d, detj) )
    end if

    nullify( prime_extrusion_mesh, detj )

  end subroutine set_rho_d_ffsl_y

  !> @brief Stores a field at the start of the whole transport step
  !> @param[in]     field_n   Field at start of whole transport step
  subroutine set_field_n(self, field_n)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: field_n

    call field_n%copy_field_properties(self%field_n)
    call invoke( setval_X(self%field_n, field_n) )

  end subroutine set_field_n

  !> @brief Sets fluxes for use in conservative transport
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     flux      Mass flux for a particular split step
  subroutine set_flux(self, flux)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: flux

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(flux%get_mesh_id())
    call flux%copy_field_properties(self%flux(idx,self%tracer_step_ctr))
    call invoke( setval_X(self%flux(idx,self%tracer_step_ctr), flux) )

  end subroutine set_flux

  !> @brief   Sets the apply_cheap_update logical.
  !> @details Sets the cheap update step to be true or false based on the cheap_option
  !!          argument. If cheap_update is true and outer_iterations > 1 this is
  !!          automatically set to true, however, for tracers transported in the
  !!          last outer step this needs to be set to false. The apply_cheap_update
  !!          is used to tell the transport scheme whether to use the full transport
  !!          scheme, or to revert to the cheap update transport scheme.
  !> @param[in] cheap_option    Logical to set apply_cheap_update
  subroutine set_apply_cheap_update(self, cheap_option)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    logical(kind=l_def),                   intent(in)    :: cheap_option

    self%apply_cheap_update = cheap_option

  end subroutine set_apply_cheap_update

  !> @brief Sets the transport substep counter
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     step_num  Which substep we are doing
  subroutine set_substep_total_ctr(self, step_num)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    integer(kind=i_def),                   intent(in)    :: step_num

    self%substep_total_ctr = step_num

  end subroutine set_substep_total_ctr

! ============================================================================ !
! DRY FIELD ROUTINES
! ============================================================================ !

  !> @brief Restricts the prime mesh dry fields from one transport_runtime
  !!        object to set the dry fields for the prime mesh of another
  !!        transport_runtime object for a coarser mesh.
  !> @param[in,out] self                       Target transport_runtime object
  !> @param[in]     source_transport_runtime   Source transport_runtime object
  subroutine restrict_dry_fields(self, source_transport_runtime)

    use sci_mapping_constants_mod, only: get_intermesh_weights_w3_rtran
    use mesh_collection_mod,       only: mesh_collection
    use sci_restrict_mass_w3_kernel_mod, &
                                   only: restrict_mass_w3_kernel_type
    use sci_restrict_scalar_weighted_kernel_mod, &
                                   only: restrict_scalar_weighted_kernel_type
    use sci_restrict_w2_kernel_mod, &
                                   only: restrict_w2_kernel_type
    use sci_restrict_w2h_kernel_mod, &
                                   only: restrict_w2h_kernel_type
    use sci_restrict_w2v_kernel_mod, &
                                   only: restrict_w2v_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    class(transport_runtime_type),         intent(in)    :: source_transport_runtime

    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(mesh_type),           pointer :: source_mesh => null()
    type(mesh_type),           pointer :: target_mesh => null()
    type(r_tran_field_type),   pointer :: source_rho_d => null()
    type(r_tran_field_type),   pointer :: source_dry_mass => null()
    type(r_tran_field_type),   pointer :: source_dry_mass_ffsl_x => null()
    type(r_tran_field_type),   pointer :: source_dry_mass_ffsl_y => null()
    type(r_tran_field_type),   pointer :: source_dry_flux => null()
    type(r_tran_field_type),   pointer :: weights_w3 => null()
    type(r_tran_field_type),   pointer :: source_detj => null()
    type(r_tran_field_type),   pointer :: target_detj => null()
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(r_tran_field_type)            :: tmp_rho_d
    type(r_tran_field_type)            :: source_rho_ffsl
    type(r_tran_field_type)            :: target_rho_ffsl
    integer(kind=i_def)                :: source_ncells
    integer(kind=i_def)                :: target_ncells
    integer(kind=i_def)                :: source_mesh_id
    integer(kind=i_def)                :: target_mesh_id
    integer(kind=i_def)                :: step, num_steps, fs_idx
    integer(kind=i_def)                :: sub_step, num_sub_steps
    integer(kind=i_def)                :: step_with_substep
    logical(kind=l_def)                :: any_hori_dep_dist
    integer(kind=i_def)                :: remap_depth

    if ( subroutine_timers ) call timer('transport.runtime_restrict')

    ! N.B. The meshes should not be the same as one another, otherwise the
    ! transport_runtime objects will be the same

    source_mesh_id = source_transport_runtime%get_prime_extrusion_mesh_id()
    target_mesh_id = self%get_prime_extrusion_mesh_id()
    ! Obtain meshes to check that we can coarsen
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)
    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    face_selector_ew => get_face_selector_ew(target_mesh_id)
    face_selector_ns => get_face_selector_ns(target_mesh_id)

    target_detj => get_detj_at_w3_r_tran(target_mesh_id)
    source_detj => get_detj_at_w3_r_tran(source_mesh_id)

    if (source_ncells > target_ncells) then
      ! Loop through fields for each step for prime extrusion
      num_steps = source_transport_runtime%get_num_dry_steps()
      num_sub_steps = source_transport_runtime%get_number_total_substeps()

      do sub_step = 1, num_sub_steps
        do step = 1, num_steps + 1

          ! ------------------------------------------------------------------ !
          ! rho_d and dry_mass
          ! ------------------------------------------------------------------ !
          ! Restrict densities conservatively
          step_with_substep = (sub_step - 1) * (num_steps + 1) + step
          source_rho_d => source_transport_runtime%get_rho_d(source_mesh_id, &
                                                             step_with_substep)
          weights_w3 => get_intermesh_weights_w3_rtran(source_mesh, target_mesh)
          w3_fs => function_space_collection%get_fs(target_mesh, 0, 0, W3)

          if (.not. self%rho_d(1,step_with_substep)%is_initialised()) then
            call self%rho_d(1,step_with_substep)%initialise(  &
                                        vector_space = w3_fs, &
                                        halo_depth=target_mesh%get_halo_depth() )
            call self%dry_mass(1,step_with_substep)%initialise( &
                                        vector_space = w3_fs,   &
                                        halo_depth=target_mesh%get_halo_depth() )
          end if

          if (extended_mesh) then
            ! TODO: we should be able to get away with not doing all of these
            ! remappings, based on the direction and last step
            ! Need to remap on the ext. mesh, and make rho and mass consistent
            ! Restrict rho, remap, and then calculate mass
            weights_w3 => get_intermesh_weights_w3_rtran(source_mesh, target_mesh)
            source_rho_d => source_transport_runtime%get_rho_d(source_mesh_id, &
                                                               step_with_substep)
            if ( check_any_horizontal_method_mol() ) then
              remap_depth = get_required_stencil_depth()
            else
              ! TODO: we should be able to get away with not doing all of these
              ! remappings, based on the direction and last step
              ! Restrict, then remap
              remap_depth = self%get_dep_stencil_extent_xy(self%mesh_ids(1), .false.) &
                          + 2_i_def + max(ffsl_inner_order, ffsl_outer_order)
            end if
            ! Restrict and remap rho
            call tmp_rho_d%initialise( vector_space = w3_fs,                   &
                                       halo_depth=target_mesh%get_halo_depth() )
            call invoke( restrict_scalar_weighted_kernel_type(tmp_rho_d,       &
                                                              source_rho_d,    &
                                                              weights_w3) )
            call remap_on_extended_mesh(self%rho_d(1,step_with_substep),  &
                                        tmp_rho_d,                        &
                                        self%rho_monotone_remap,          &
                                        self%rho_enforce_minvalue,        &
                                        self%rho_minvalue, remap_depth)
            ! Now compute mass by multiplying remapped field by det(J)
            ! @todo #4302: replace this with redundant computation
            call invoke_deep_X_times_Y(self%dry_mass(1,step_with_substep),     &
                                       self%rho_d(1,step_with_substep),        &
                                       target_detj)
          else
            ! Can restrict mass and then obtain density through division
            source_dry_mass => source_transport_runtime%get_dry_mass(          &
                                                             source_mesh_id,   &
                                                             step_with_substep)
            call invoke( restrict_mass_w3_kernel_type(                         &
                                      self%dry_mass(1,step_with_substep),      &
                                      source_dry_mass),                        &
                         X_divideby_Y(self%rho_d(1,step_with_substep),         &
                                      self%dry_mass(1,step_with_substep),      &
                                      target_detj) )
          end if

          ! ------------------------------------------------------------------ !
          ! dry_mass_ffsl: only used with FFSL and only for number of dry steps
          ! ------------------------------------------------------------------ !
          any_hori_dep_dist = check_horz_dep_pts()
          if ( any_hori_dep_dist .and. step < num_steps + 1 ) then
            step_with_substep = (sub_step - 1) * num_steps + step
            if ( source_transport_runtime%dry_mass_ffsl_x(1,step)%is_initialised() ) then
              source_dry_mass_ffsl_x => source_transport_runtime%get_dry_mass_ffsl_x( &
                                                    source_mesh_id, step_with_substep)
              source_dry_mass_ffsl_y => source_transport_runtime%get_dry_mass_ffsl_y( &
                                                    source_mesh_id, step_with_substep)

              if (.not. self%dry_mass_ffsl_x(1,step_with_substep)%is_initialised()) then
                call self%dry_mass_ffsl_x(1,step_with_substep)%initialise(     &
                                                vector_space = w3_fs,          &
                                                halo_depth=target_mesh%get_halo_depth() )
                call self%dry_mass_ffsl_y(1,step_with_substep)%initialise(     &
                                                vector_space = w3_fs,          &
                                                halo_depth=target_mesh%get_halo_depth() )
              end if

              call source_rho_ffsl%initialise(                                 &
                              source_dry_mass_ffsl_x%get_function_space(),     &
                              halo_depth=source_mesh%get_halo_depth() )
              call target_rho_ffsl%initialise(                                 &
                              w3_fs,                                           &
                              halo_depth=target_mesh%get_halo_depth() )

              if (extended_mesh) then
                ! As this will be used for computing departure distances,
                ! compute to full stencil depth
                remap_depth = get_required_stencil_depth()

                ! Restrict and remap rho
                call invoke( X_divideby_Y(source_rho_ffsl,                      &
                                          source_dry_mass_ffsl_x, source_detj), &
                             restrict_scalar_weighted_kernel_type(              &
                                                      tmp_rho_d,                &
                                                      source_rho_ffsl,          &
                                                      weights_w3) )
                call remap_on_extended_mesh(target_rho_ffsl,                   &
                                            tmp_rho_d,                         &
                                            self%rho_monotone_remap,           &
                                            self%rho_enforce_minvalue,         &
                                            self%rho_minvalue, remap_depth)
                ! @todo #4302: replace this with redundant computation
                call invoke_deep_X_times_Y(                                      &
                                     self%dry_mass_ffsl_x(1, step_with_substep), &
                                     target_rho_ffsl,                            &
                                     target_detj)
                call invoke( X_divideby_Y(source_rho_ffsl,                       &
                                          source_dry_mass_ffsl_y, source_detj),  &
                             restrict_scalar_weighted_kernel_type(               &
                                                      tmp_rho_d,                 &
                                                      source_rho_ffsl,           &
                                                      weights_w3) )
                call remap_on_extended_mesh(target_rho_ffsl,                   &
                                            tmp_rho_d,                         &
                                            self%rho_monotone_remap,           &
                                            self%rho_enforce_minvalue,         &
                                            self%rho_minvalue, remap_depth)
                ! Now remap mass
                ! @todo #4302: replace this with redundant computation
                call invoke_deep_X_times_Y(                                      &
                                     self%dry_mass_ffsl_y(1, step_with_substep), &
                                     target_rho_ffsl,                            &
                                     target_detj)

              else
                ! Can restrict straight into mass fields fields
                call invoke( restrict_mass_w3_kernel_type(                       &
                                     self%dry_mass_ffsl_x(1, step_with_substep), &
                                     source_dry_mass_ffsl_x),                    &
                             restrict_mass_w3_kernel_type(                       &
                                     self%dry_mass_ffsl_y(1, step_with_substep), &
                                     source_dry_mass_ffsl_y) )

              end if
            end if
          end if

          ! ------------------------------------------------------------------ !
          ! dry_flux: kernel depends on the direction
          ! ------------------------------------------------------------------ !
          if ( step < num_steps + 1 ) then

            step_with_substep = (sub_step - 1) * num_steps + step
            source_dry_flux => source_transport_runtime%get_dry_flux(source_mesh_id, step_with_substep)

            fs_idx = source_dry_flux%which_function_space()
            if (.not. self%dry_flux(1,step_with_substep)%is_initialised()) then
              w2_fs => function_space_collection%get_fs(target_mesh, 0, 0, fs_idx)
              call self%dry_flux(1,step_with_substep)%initialise( vector_space = w2_fs )
            end if

            ! Restrict flux, which depends on split direction
            select case ( source_dry_flux%which_function_space() )
            case ( W2 )
              call invoke(                                                     &
                  restrict_w2_kernel_type(self%dry_flux(1,step_with_substep),  &
                                          source_dry_flux,                     &
                                          face_selector_ew,                    &
                                          face_selector_ns) )
            case ( W2H )
              call invoke(                                                     &
                  restrict_w2h_kernel_type(self%dry_flux(1,step_with_substep), &
                                           source_dry_flux,                    &
                                           face_selector_ew,                   &
                                           face_selector_ns) )
            case ( W2V )
              call invoke(                                                     &
                  restrict_w2v_kernel_type(self%dry_flux(1,step_with_substep), source_dry_flux) )
            case default
              call log_event('Dry flux space not recognised', LOG_LEVEL_ERROR)
            end select
          end if  ! step is valid for dry flux

        end do  ! loop through steps
      end do  ! loop through transport sub steps
    else
      call log_event( 'Can only call restrict_dry_fields when ' //             &
                      'target mesh is coarser than source mesh', LOG_LEVEL_ERROR)
    end if

    nullify( source_mesh, target_mesh, source_rho_d, source_dry_mass_ffsl_x,   &
             source_dry_mass_ffsl_y, source_dry_flux, w3_fs, w2_fs,            &
             weights_w3, face_selector_ew, face_selector_ns )

    if ( subroutine_timers ) call timer('transport.runtime_restrict')

  end subroutine restrict_dry_fields

  !> @brief Computes stored dry fields on the shifted mesh for consistent
  !!        transport of Wtheta tracers
  !> @param[in] use_total_quantities
  !!                           Logical to determine if the total_quantities
  !!                           need to be shifted (this is for the last
  !!                           outer tracers when the cheap update is being used)
  subroutine shift_dry_fields(self, use_total_quantities)

    use sci_consist_w2_to_sh_w2_kernel_mod,   only: consist_w2_to_sh_w2_kernel_type
    use sci_consist_w2h_to_sh_w2h_kernel_mod, only: consist_w2h_to_sh_w2h_kernel_type
    use sci_consist_w2v_to_sh_w2v_kernel_mod, only: consist_w2v_to_sh_w2v_kernel_type
    use psykal_lite_transport_mod,            only: invoke_deep_shift_mass, &
                                                    invoke_deep_X_divideby_Y
    use sci_shift_mass_w3_kernel_mod,         only: shift_mass_w3_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    logical(kind=l_def),                   intent(in)    :: use_total_quantities

    integer(kind=i_def)                :: prime_mesh_id, fs_idx, step
    type(mesh_type),           pointer :: prime_extrusion_mesh => null()
    type(mesh_type),           pointer :: shifted_mesh => null()
    type(r_tran_field_type),   pointer :: detj_shifted => null()
    type(r_tran_field_type),   pointer :: detj_prime => null()
    type(r_tran_field_type)            :: rho_d_prime
    type(r_tran_field_type)            :: rho_d_shifted
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    logical(kind=l_def)                :: any_hori_dep_dist
    integer(kind=i_def)                :: num_steps
    integer(kind=i_def)                :: sub_step, num_sub_steps
    integer(kind=i_def)                :: step_with_substep

    if ( subroutine_timers ) call timer('transport.runtime_shift')

    any_hori_dep_dist = check_horz_dep_pts()

    if (self%n_meshes > 1) then
      prime_extrusion_mesh => mesh_collection%get_mesh(self%mesh_ids(1))
      prime_mesh_id = prime_extrusion_mesh%get_id()
      shifted_mesh => mesh_collection%get_mesh(self%mesh_ids(2))

      detj_shifted => get_detj_at_w3_r_tran(shifted_mesh%get_id())
      detj_prime => get_detj_at_w3_r_tran(prime_mesh_id)
      w3_fs => function_space_collection%get_fs(shifted_mesh, 0, 0, W3)

      face_selector_ew => get_face_selector_ew(prime_mesh_id)
      face_selector_ns => get_face_selector_ns(prime_mesh_id)

      num_steps = self%num_dry_steps
      num_sub_steps = self%number_total_substeps

      do sub_step = 1, num_sub_steps
        do step = 1, num_steps + 1

          ! ------------------------------------------------------------------ !
          ! rho_d and dry_mass
          ! ------------------------------------------------------------------ !
          step_with_substep = (sub_step - 1) * (num_steps+1) + step
          if (.not. self%rho_d(2,step_with_substep)%is_initialised()) then
            call self%rho_d(2,step_with_substep)%initialise(                   &
                                     vector_space = w3_fs,                     &
                                     halo_depth=shifted_mesh%get_halo_depth() )
            call self%dry_mass(2,step_with_substep)%initialise(                &
                                     vector_space = w3_fs,                     &
                                     halo_depth=shifted_mesh%get_halo_depth() )
          end if

          ! If using cheap update and it is the last outer semi-implicit step
          ! we must use the combined dry mass
          if (use_total_quantities) then
            call invoke( setval_X(self%dry_mass(1,step),                       &
                                  self%total_dry_mass(1,step)),                &
                         setval_X(self%rho_d(1,step),                          &
                                  self%total_rho_d(1,step)) )
          end if

          if (extended_mesh) then
            ! Original field has already been remapped, so can perform a "deep"
            ! shift on the original field to get the shifted, remapped density
            ! @todo #4302: replace this with redundant computation
            call invoke_deep_shift_mass(self%dry_mass(2,step_with_substep),    &
                                        self%dry_mass(1,step_with_substep))
            call invoke_deep_X_divideby_Y(self%rho_d(2,step_with_substep),     &
                                          self%dry_mass(2,step_with_substep),  &
                                          detj_shifted)
          else
            ! Can directly shift mass, then obtain rho by dividing by volume
            call invoke( shift_mass_w3_kernel_type(                            &
                                          self%dry_mass(2,step_with_substep),  &
                                          self%dry_mass(1,step_with_substep)), &
                         X_divideby_Y(self%rho_d(2,step_with_substep),         &
                                      self%dry_mass(2,step_with_substep),      &
                                      detj_shifted) )
          end if

          ! ------------------------------------------------------------------ !
          ! dry_mass_ffsl: only used with FFSL and only for number of dry steps
          ! ------------------------------------------------------------------ !
          if ( any_hori_dep_dist .and. step < self%num_dry_steps + 1 ) then
            step_with_substep = (sub_step - 1) * num_steps + step
            if ( self%dry_mass_ffsl_x(1,step_with_substep)%is_initialised() ) then
              if (.not. self%dry_mass_ffsl_x(2,step_with_substep)%is_initialised()) then
                call self%dry_mass_ffsl_x(2,step_with_substep)%initialise(     &
                                          vector_space = w3_fs,                &
                                          halo_depth=shifted_mesh%get_halo_depth() )
                call self%dry_mass_ffsl_y(2,step_with_substep)%initialise(     &
                                          vector_space = w3_fs,                &
                                          halo_depth=shifted_mesh%get_halo_depth() )
              end if

              call rho_d_prime%initialise( self%dry_mass_ffsl_x(1,step_with_substep)%get_function_space(), &
                                           halo_depth=prime_extrusion_mesh%get_halo_depth() )
              call rho_d_shifted%initialise( w3_fs, &
                                           halo_depth=shifted_mesh%get_halo_depth() )

              ! If using cheap update and it is the last outer semi-implicit step
              ! we must use the combined mass
              if (use_total_quantities) then
                call invoke( setval_X(self%dry_mass_ffsl_x(1,step),            &
                                      self%total_dry_mass_ffsl_x(1,step)),     &
                             setval_X(self%dry_mass_ffsl_y(1,step),            &
                                      self%total_dry_mass_ffsl_y(1,step)) )
              end if

              if (extended_mesh) then
                ! Mass should already correspond to remapped density
                ! Rather than remapping, perform deep shifting of mass into halos
                ! @todo #4302: replace this with redundant computation
                call invoke_deep_shift_mass(                                   &
                                    self%dry_mass_ffsl_x(2,step_with_substep), &
                                    self%dry_mass_ffsl_x(1,step_with_substep))
                call invoke_deep_shift_mass(                                   &
                                    self%dry_mass_ffsl_y(2,step_with_substep), &
                                    self%dry_mass_ffsl_y(1,step_with_substep))

              else
                ! Can just directly shift mass
                call invoke( shift_mass_w3_kernel_type(                        &
                                   self%dry_mass_ffsl_x(2,step_with_substep),  &
                                   self%dry_mass_ffsl_x(1,step_with_substep)), &
                             shift_mass_w3_kernel_type(                        &
                                   self%dry_mass_ffsl_y(2,step_with_substep),  &
                                   self%dry_mass_ffsl_y(1,step_with_substep)) )
              end if
            end if
          end if

          ! ------------------------------------------------------------------ !
          ! dry_flux: kernel depends on the direction
          ! ------------------------------------------------------------------ !
          if ( step < self%num_dry_steps + 1 ) then
            step_with_substep = (sub_step - 1) * num_steps + step
            ! Transform dry fluxes to the shifted mesh, with case depending on fs_idx
            fs_idx = self%dry_flux(1,step_with_substep)%which_function_space()

            if (.not. self%dry_flux(2,step_with_substep)%is_initialised()) then
              w2_fs => function_space_collection%get_fs(shifted_mesh, 0, 0, fs_idx)
              call self%dry_flux(2,step_with_substep)%initialise( vector_space = w2_fs )
            end if

            ! If using cheap update and it is the last outer semi-implicit step
            ! we must use the total flux
            if (use_total_quantities) then
              call invoke( setval_X(self%dry_flux(1,step),                     &
                                    self%total_dry_flux(1,step)) )
            end if

            select case (fs_idx)
            case (W2)
              call invoke(                                                     &
                setval_c(self%dry_flux(2,step_with_substep), 0.0_r_tran),      &
                consist_w2_to_sh_w2_kernel_type(                               &
                                           self%dry_flux(2,step_with_substep), &
                                           self%dry_flux(1,step_with_substep), &
                                           face_selector_ew,                   &
                                           face_selector_ns) )
            case (W2h)
              call invoke(                                                     &
                setval_c(self%dry_flux(2,step_with_substep), 0.0_r_tran),      &
                consist_w2h_to_sh_w2h_kernel_type(                             &
                                           self%dry_flux(2,step_with_substep), &
                                           self%dry_flux(1,step_with_substep), &
                                           face_selector_ew,                   &
                                           face_selector_ns) )
            case (W2v)
              call invoke(                                                     &
                consist_w2v_to_sh_w2v_kernel_type(                             &
                                           self%dry_flux(2,step_with_substep), &
                                           self%dry_flux(1,step_with_substep)) )
            case default
              call log_event( "Can only store dry flux for W2, W2h and W2v spaces", LOG_LEVEL_ERROR )
            end select
          end if  ! step is valid for dry flux

        end do  ! loop through steps
      end do  ! loop through transport sub steps
    end if  ! there is a shifted mesh

    nullify( prime_extrusion_mesh, shifted_mesh, detj_shifted, detj_prime, &
             w3_fs, w2_fs, face_selector_ew, face_selector_ns )

    if ( subroutine_timers ) call timer('transport.runtime_shift')

  end subroutine shift_dry_fields

  !> @brief Computes quantities (such as departure points) necessary for the
  !!        consistent transport of tracers using FFSL
  !> @param[in,out] self   The transport_runtime object
  !> @param[in]     mesh   The mesh to compute consistent quantities on
  subroutine compute_consistent_quantities(self, mesh)

    use base_mesh_config_mod,                 only: topology, geometry,        &
                                                    topology_fully_periodic,   &
                                                    geometry_spherical
    use calc_dep_pts_alg_mod,                 only: calc_ffsl_hori_dep_pts
    use vert_dep_dist_ffsl_kernel_mod,        only: vert_dep_dist_ffsl_kernel_type
    use departure_points_config_mod,          only: horizontal_limit, &
                                                    horizontal_limit_cap
    use ffsl_panel_swap_kernel_mod,           only: ffsl_panel_swap_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(mesh_type),                       intent(in)    :: mesh

    integer(kind=i_def)                :: mesh_id, i, step
    integer(kind=i_def)                :: function_space
    integer(kind=i_def)                :: max_stencil_extent
    integer(kind=i_def)                :: num_steps
    integer(kind=i_def)                :: sub_step, num_sub_steps
    integer(kind=i_def)                :: step_with_substep
    integer(kind=i_def)                :: step_p1_with_substep
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w3_2d_fs => null()
    type(r_tran_field_type),   pointer :: dry_mass => null()
    type(r_tran_field_type),   pointer :: dry_mass_copy => null()
    type(r_tran_field_type),   pointer :: dry_mass_x => null()
    type(r_tran_field_type),   pointer :: dry_mass_y => null()
    type(r_tran_field_type),   pointer :: dry_flux => null()
    type(field_type),          pointer :: panel_id => null()
    logical(kind=l_def)                :: any_eqn_consistent, cap_dep_points
    logical(kind=l_def)                :: any_vert_dep_dist, any_hori_dep_dist
    logical(kind=l_def)                :: any_consistent_swift
    logical(kind=l_def)                :: any_consistent_cosmic
    character(len=str_def)             :: field_name

    if ( subroutine_timers ) call timer('transport.runtime_consistent')

    any_eqn_consistent = check_any_eqn_consistent()
    any_consistent_swift = check_any_consistent_swift()
    any_consistent_cosmic = check_any_consistent_cosmic()
    any_vert_dep_dist = check_vert_dep_pts()
    any_hori_dep_dist = check_horz_dep_pts()

    if ( ( any_consistent_swift .or. any_consistent_cosmic .or. &
          (any_eqn_consistent .and. any_vert_dep_dist) )        &
          .and. .not. self%advective_first_outer ) then

      mesh_id = mesh%get_id()
      i = self%idx_from_mesh_id(mesh_id)
      panel_id => get_panel_id(mesh_id)

      num_steps = self%num_dry_steps
      num_sub_steps = self%number_total_substeps

      do sub_step = 1, num_sub_steps
        do step = 1, num_steps

          step_p1_with_substep = (sub_step - 1) * (num_steps+1) + step
          dry_mass => self%get_dry_mass(mesh_id, step_p1_with_substep)
          dry_mass_copy => self%get_dry_mass(mesh_id, step_p1_with_substep)
          step_with_substep = (sub_step - 1) * num_steps + step
          dry_flux => self%get_dry_flux(mesh_id, step_with_substep)
          ! Check that mass isn't negative
          write(field_name, '(A,I4)') 'dry_mass', step
          call self%check_negative_field(dry_mass, field_name)

          ! Determine direction of step from function space
          function_space = dry_flux%which_function_space()

          ! ------------------------------------------------------------------ !
          ! Vertical step
          ! ------------------------------------------------------------------ !
          if (function_space == W2V .and. any_vert_dep_dist) then
            if (.not. self%tracer_dep_dist_z(i,step_with_substep)%is_initialised()) then
              w2_fs => dry_flux%get_function_space()
              call self%tracer_dep_dist_z(i,step_with_substep)%initialise( w2_fs )
              call self%dry_frac_flux_z(i,step_with_substep)%initialise( w2_fs )
            end if

            call invoke( vert_dep_dist_ffsl_kernel_type(                       &
                                  self%tracer_dep_dist_z(i,step_with_substep), &
                                  self%dry_frac_flux_z(i,step_with_substep),   &
                                  dry_flux,                                    &
                                  dry_mass) )

            call log_field_minmax(LOG_LEVEL_DEBUG, 'tracer_dep_dist_z',        &
                                  self%tracer_dep_dist_z(i,step_with_substep))
          ! ------------------------------------------------------------------ !
          ! Horizontal step
          ! ------------------------------------------------------------------ !
          else if (function_space == W2H .and. any_hori_dep_dist) then

            cap_dep_points = (horizontal_limit == horizontal_limit_cap)

            ! Inner step quantities ----------------------------------------------
            if (.not. self%tracer_dep_dist_ixy(i,step_with_substep)%is_initialised()) then
              w2_fs => dry_flux%get_function_space()
              twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
              w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, 0, W3)
              call self%tracer_dep_dist_ixy(i,step_with_substep)%initialise( w2_fs )
              call self%dry_frac_flux_ixy(i,step_with_substep)%initialise( w2_fs )
            end if

            ! Compute tracer departure points
            call calc_ffsl_hori_dep_pts(                                       &
                          self%tracer_dep_dist_ixy(i,step_with_substep),       &
                          self%dry_frac_flux_ixy(i,step_with_substep),         &
                          self%tracer_stencil_extent_ixy(i,step_with_substep), &
                          dry_flux, dry_mass, dry_mass_copy                    &
            )

            ! Outer step quantities ----------------------------------------------
            ! Determine if outer fields needed from initialisation of dry_mass_ffsl
            if (any_consistent_swift) then
              if (.not. self%tracer_dep_dist_oxy(i,step_with_substep)%is_initialised()) then
                w2_fs => dry_flux%get_function_space()
                twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
                w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, 0, W3)
                call self%tracer_dep_dist_oxy(i,step_with_substep)%initialise( w2_fs )
                call self%dry_frac_flux_oxy(i,step_with_substep)%initialise( w2_fs )
              end if

              dry_mass_x => self%get_dry_mass_ffsl_x(mesh_id, step_with_substep)
              dry_mass_y => self%get_dry_mass_ffsl_y(mesh_id, step_with_substep)

              ! Check that mass isn't negative
              write(field_name, '(A,I4)') 'dry_mass_ffsl_x', step_with_substep
              call self%check_negative_field(dry_mass_x, field_name)
              write(field_name, '(A,I4)') 'dry_mass_ffsl_y', step_with_substep
              call self%check_negative_field(dry_mass_y, field_name)

              if (topology == topology_fully_periodic &
                  .AND. geometry == geometry_spherical) then
                ! Swap the halo values of dry_mass_x and dry_mass_y here: this
                ! reduces the number of different kernels required by FFSL
                max_stencil_extent = get_required_stencil_depth()
                call invoke( ffsl_panel_swap_kernel_type(dry_mass_x, &
                                                         dry_mass_y, &
                                                         panel_id,   &
                                                         max_stencil_extent) )
              end if

            ! Compute tracer departure points
            call calc_ffsl_hori_dep_pts(                                       &
                          self%tracer_dep_dist_oxy(i,step_with_substep),       &
                          self%dry_frac_flux_oxy(i,step_with_substep),         &
                          self%tracer_stencil_extent_oxy(i,step_with_substep), &
                          dry_flux, dry_mass_y, dry_mass_x                     &
            )

            end if  ! Outer step variables
          end if  ! Horizontal
        end do  ! Loop through steps
      end do  ! Loop through sub steps
    end if  ! Whether consistent quantities need computing

    nullify(w2_fs, w3_2d_fs, dry_mass, dry_mass_x, dry_mass_y, &
            dry_flux, twod_mesh, panel_id)

    if ( subroutine_timers ) call timer('transport.runtime_consistent')

  end subroutine compute_consistent_quantities

  !> @brief Computes density quantities necessary for the consistent
  !!        transport of tracers using FFSL during the last outer
  !!        semi-implicit step when the cheap update transport is used
  subroutine compute_total_rho_quantities(self)

    use base_mesh_config_mod,           only: topology, topology_non_periodic
    use boundaries_config_mod,          only: limited_area, transport_boundary_depth
    use fs_continuity_mod,              only: W2, W2H, W2V
    use fv_divergence_2d_kernel_mod,    only: fv_divergence_2d_kernel_type
    use fv_divergence_3d_kernel_mod,    only: fv_divergence_3d_kernel_type
    use fv_divergence_x_kernel_mod,     only: fv_divergence_x_kernel_type
    use fv_divergence_y_kernel_mod,     only: fv_divergence_y_kernel_type
    use fv_divergence_z_kernel_mod,     only: fv_divergence_z_kernel_type
    use limited_area_lbc_alg_mod,       only: overwrite_blending_zone_rtran
    use transport_constants_mod,        only: get_detj_at_w3_r_tran
    use transport_enumerated_types_mod, only: direction_3d, &
                                              direction_h,  &
                                              direction_v

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    ! Integers
    integer(kind=i_def) :: number_of_steps
    integer(kind=i_def) :: step
    integer(kind=i_def) :: fs_idx
    integer(kind=i_def) :: direction
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: stencil_depth

    ! Pointers
    type(r_tran_field_type),   pointer :: detj_at_w3
    type(function_space_type), pointer :: field_fs

    ! Fields
    type(r_tran_field_type) :: increment
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y

    ! We must use the incremented "total" fluxes for consistent tracer
    ! in the last outer step if the cheap update is used

    ! Get number of steps in split transport
    number_of_steps = self%num_dry_steps

    ! Get Det(J) and field function space
    mesh_id = self%rho_d(1,1)%get_mesh_id()
    field_fs => self%rho_d(1,1)%get_function_space()
    detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)

    ! Initialise increments
    call increment%initialise( vector_space = field_fs )
    call increment_x%initialise( vector_space = field_fs )
    call increment_y%initialise( vector_space = field_fs )

    ! Get the stencil depth
    stencil_depth = get_required_stencil_depth()

    ! Initialise "total" variables
    do step = 1, number_of_steps
      call self%total_rho_d(1,step)%initialise(              &
                                    vector_space = field_fs, &
                                    halo_depth = stencil_depth )
      call self%total_dry_mass(1,step)%initialise(           &
                                    vector_space = field_fs, &
                                    halo_depth = stencil_depth )
      call self%total_dry_mass_ffsl_x(1,step)%initialise(    &
                                    vector_space = field_fs, &
                                    halo_depth = stencil_depth )
      call self%total_dry_mass_ffsl_y(1,step)%initialise(    &
                                    vector_space = field_fs, &
                                    halo_depth = stencil_depth )
    end do

    call self%total_rho_d(1,number_of_steps+1)%initialise(    &
                                    vector_space = field_fs,  &
                                    halo_depth = stencil_depth )
    call self%total_dry_mass(1,number_of_steps+1)%initialise( &
                                    vector_space = field_fs,  &
                                    halo_depth = stencil_depth )

    ! Set first rho and dry mass to be rho_n
    call invoke( setval_X(self%total_rho_d(1,1), self%rho_d(1,1)), &
                 setval_X(self%total_dry_mass(1,1), self%dry_mass(1,1)) )

    ! Compute divergence of fluxes for each split step
    do step = 1, number_of_steps

      ! Determine direction of transport
      fs_idx = self%total_dry_flux(1,step)%which_function_space()
      select case (fs_idx)
      case (W2H)
        direction = direction_h
      case (W2V)
        direction = direction_v
      case (W2)
        direction = direction_3d
      end select

      ! Can use quicker lowest-order kernels to take the divergence
      select case (direction)

      case (direction_3d)
        call invoke( fv_divergence_3d_kernel_type(increment,                   &
                                                  self%total_dry_flux(1,step), &
                                                  detj_at_w3),                 &
                     X_minus_Y(self%total_rho_d(1,step+1),                     &
                               self%total_rho_d(1,step), increment),           &
                     X_times_Y(self%total_dry_mass(1,step+1),                  &
                               self%total_rho_d(1,step+1), detj_at_w3) )

      case (direction_h)
        call invoke( fv_divergence_2d_kernel_type(increment,                   &
                                                  self%total_dry_flux(1,step), &
                                                  detj_at_w3),                 &
                     X_minus_Y(self%total_rho_d(1,step+1),                     &
                               self%total_rho_d(1,step), increment),           &
                     X_times_Y(self%total_dry_mass(1,step+1),                  &
                               self%total_rho_d(1,step+1), detj_at_w3),        &
        ! Compute total_rho_d_ffsl in x and y
                     fv_divergence_x_kernel_type(increment_x,                  &
                                                 self%total_dry_flux(1,step),  &
                                                 detj_at_w3),                  &
                     fv_divergence_y_kernel_type(increment_y,                  &
                                                 self%total_dry_flux(1,step),  &
                                                 detj_at_w3),                  &
                     X_minus_Y(self%total_dry_mass_ffsl_x(1,step),             &
                               self%total_rho_d(1,step),                       &
                               increment_x),                                   &
                     X_minus_Y(self%total_dry_mass_ffsl_y(1,step),             &
                               self%total_rho_d(1,step),                       &
                               increment_y),                                   &
                     inc_X_times_Y(self%total_dry_mass_ffsl_x(1,step),         &
                                   detj_at_w3),                                &
                     inc_X_times_Y(self%total_dry_mass_ffsl_y(1,step),         &
                                   detj_at_w3) )
        if ( limited_area .and. topology == topology_non_periodic ) then
          call overwrite_blending_zone_rtran(self%total_dry_mass_ffsl_x(1,step), &
                                             self%total_rho_d(1,step),           &
                                             depth=transport_boundary_depth)
          call overwrite_blending_zone_rtran(self%total_dry_mass_ffsl_x(1,step), &
                                             self%total_rho_d(1,step),           &
                                             depth=transport_boundary_depth)
        end if

      case (direction_v)
        call invoke( fv_divergence_z_kernel_type(increment,                    &
                                                 self%total_dry_flux(1,step),  &
                                                 detj_at_w3),                  &
                     X_minus_Y(self%total_rho_d(1,step+1),                     &
                               self%total_rho_d(1,step), increment),           &
                     X_times_Y(self%total_dry_mass(1,step+1),                  &
                               self%total_rho_d(1,step+1), detj_at_w3) )
      end select

    end do

    nullify(detj_at_w3, field_fs)

  end subroutine compute_total_rho_quantities

! ============================================================================ !
! GETTERS
! ============================================================================ !

  !> @brief Returns the number of FFSL substeps
  !> @return number_total_substeps the number of substeps for FFSL transport
  function get_number_total_substeps(self) result(number_total_substeps)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: number_total_substeps

    number_total_substeps = self%number_total_substeps

  end function get_number_total_substeps

  !> @brief Computes number of MoL substeps for a splitting step
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @param[in] cfl_arg    CFL to use. Optional, and if not provided defaults
  !!                       to namelist options.
  !> @return number_mol_substeps
  !!                       Number of MOL substeps
  function get_number_mol_substeps(self, mesh_id, direction, splitting, cfl_arg) result(number_mol_substeps)
    use transport_config_mod,           only: cfl_mol_3d_stab, &
                                              cfl_mol_2d_stab, &
                                              cfl_mol_1d_stab
    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    real(kind=r_def),   optional,  intent(in) :: cfl_arg
    integer(kind=i_def)                       :: number_mol_substeps
    integer(kind=i_def)                       :: idx
    real(kind=r_def)                          :: cfl_to_use

    idx = self%idx_from_mesh_id(mesh_id)

    if (present(cfl_arg)) then
      cfl_to_use = cfl_arg + tiny_eps
    else
      select case (direction)
      case (direction_v)
        cfl_to_use = cfl_mol_1d_stab + tiny_eps
      case (direction_h)
        cfl_to_use = cfl_mol_2d_stab+tiny_eps
      case (direction_3d)
        cfl_to_use = cfl_mol_3d_stab+tiny_eps
      case default
        call log_event('Direction not recognised', LOG_LEVEL_ERROR)
      end select
    end if

    select case (direction)

      case (direction_v)
        number_mol_substeps = int( self%vertical_cfl_max(idx) / cfl_to_use, i_def) &
                         + 1_i_def
        ! Strang_vhv splitting uses half timestep for the vertical stage
        if ( splitting == splitting_strang_vhv ) then
          number_mol_substeps = int( self%vertical_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if
      case (direction_h)
        number_mol_substeps = int( self%horizontal_cfl_max(idx)      &
                              / cfl_to_use, i_def) &
                        + 1_i_def
        ! Strang_hvh splitting uses half timestep for the horizontal stage
        if ( splitting == splitting_strang_hvh ) then
          number_mol_substeps = int( self%horizontal_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if

      case (direction_3d)
        number_mol_substeps = int( self%total_cfl_max(idx)            &
                              / cfl_to_use, i_def)  &
                         + 1_i_def
      case default
        number_mol_substeps = 1_i_def
    end select

  end function get_number_mol_substeps

  !> @brief Get the MoL dt for substeps for this mesh / direction / splitting
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @return dt_substep    The dt for MoL substeps
  function get_dt_substep(self, mesh_id, direction, splitting) result(dt_substep)

    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    integer(kind=i_def)                       :: number_mol_substeps
    real(kind=r_tran)                         :: dt_substep

    number_mol_substeps = self%get_number_mol_substeps(mesh_id, direction, splitting)
    dt_substep = real(self%model_clock%get_seconds_per_step(), r_tran) &
                 / real(number_mol_substeps, r_tran)
    if ( splitting  == splitting_strang_vhv .and. direction == direction_v ) then
        dt_substep = dt_substep / 2.0_r_tran
    else if ( splitting  == splitting_strang_hvh .and. direction == direction_h ) then
        dt_substep = dt_substep / 2.0_r_tran
    end if

  end function get_dt_substep

  !> @brief Returns the local mesh id for the transport_runtime
  !> @return The identifier for the underlying local mesh
  function get_local_mesh_id(self) result(local_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: local_mesh_id

    local_mesh_id = self%local_mesh_id

  end function get_local_mesh_id

  !> @brief Returns the mesh id for the transport_runtime prime extrusion mesh
  !> @return The identifier for the prime extrusion mesh
  function get_prime_extrusion_mesh_id(self) result(prime_extrusion_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: prime_extrusion_mesh_id

    prime_extrusion_mesh_id = self%mesh_ids(1)

  end function get_prime_extrusion_mesh_id

  !> @brief Returns a pointer to the advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The advecting wind for that mesh
  function get_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'advecting_wind'
    advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_advecting_wind

  !> @brief Returns a pointer to the advecting wind associated with a direction
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @param[in] direction  The enumerator for the direction
  !> @return The advecting wind for that mesh and specified direction
  function get_directional_advecting_wind(self, mesh_id, direction) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: direction
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'directional_advecting_wind'

    select case (direction)
    case (direction_3d)
      advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_h)
      advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_v)
      advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case default
      call log_event('get_directional_advecting_wind: Direction not recognised', LOG_LEVEL_ERROR)
    end select

    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_directional_advecting_wind

   !> @brief Returns a pointer to the horizontal advecting wind
   !> @param[in] mesh_id The ID of the mesh to get the object for
   !> @return The horizontal part of the advecting wind
  function get_horizontal_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'horizontal_advecting_wind'
    advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_horizontal_advecting_wind

  !> @brief Returns a pointer to the vertical advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The vertical part of the advecting wind
  function get_vertical_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'vertical_advecting_wind'
    advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_vertical_advecting_wind

  !> @brief Returns a pointer to the adjusted vertical advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the object for
  !> @return The vertical part of the advecting wind for particular step
  function get_adjusted_v_wind(self, mesh_id, step) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'adjusted_v_wind'
    if (step == 1) then
      advecting_wind => self%adjusted_v_wind(self%idx_from_mesh_id(mesh_id), 1)
    else if (step == self%num_dry_steps) then
      advecting_wind => self%adjusted_v_wind(self%idx_from_mesh_id(mesh_id), 2)
    else
      call log_event('No adjusted v wind for this step', LOG_LEVEL_ERROR)
    end if
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_adjusted_v_wind

  !> @brief Returns a pointer to the horizontal departure distances at W2h DoFs
  !> @param[in] mesh_id     The ID of the mesh to get the object for
  !> @param[in] strang      Logical for whether to return Strang split points
  !> @param[in] outer_step  Logical for whether to return points for outer step
  !> @return The departure distances at W2h DoFs
  function get_dep_dist_xy_w2(self, mesh_id, strang, outer_step) result(dep_dist_xy_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: dep_dist_xy_w2
    character(str_def)                                :: field_name

    field_name = 'dep_dist_xy_w2'
    if (strang .and. outer_step) then
      dep_dist_xy_w2 => self%dep_dist_oxy_half_w2(self%idx_from_mesh_id(mesh_id))
    else if (strang) then
      dep_dist_xy_w2 => self%dep_dist_xy_half_w2(self%idx_from_mesh_id(mesh_id))
    else if (outer_step) then
      dep_dist_xy_w2 => self%dep_dist_oxy_w2(self%idx_from_mesh_id(mesh_id))
    else
      dep_dist_xy_w2 => self%dep_dist_xy_w2(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(dep_dist_xy_w2, field_name, mesh_id)

  end function get_dep_dist_xy_w2

  !> @brief Returns a pointer to the z departure distances at W2v DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split distances
  !> @return The departure distances for the z direction at W2v DoFs
  function get_dep_dist_z_w2(self, mesh_id, strang) result(dep_dist_z_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: dep_dist_z_w2
    character(str_def)                                :: field_name

    field_name = 'dep_dist_z_w2'
    if (strang) then
      dep_dist_z_w2 => self%dep_dist_z_half_w2(self%idx_from_mesh_id(mesh_id))
    else
      dep_dist_z_w2 => self%dep_dist_z_w2(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(dep_dist_z_w2, field_name, mesh_id)

  end function get_dep_dist_z_w2

  !> @brief Returns a pointer to the detj_at_w3 field transported in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split volume
  !> @return The cell volume after transport in x
  function get_adv_detj_x(self, mesh_id, strang) result(detj_at_w3)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: detj_at_w3
    character(str_def)                                :: field_name

    field_name = 'adv_detj_x'
    if (strang) then
      detj_at_w3 => self%adv_detj_x_half(self%idx_from_mesh_id(mesh_id))
    else
      detj_at_w3 => self%adv_detj_x(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(detj_at_w3, field_name, mesh_id)

  end function get_adv_detj_x

  !> @brief Returns a pointer to the detj_at_w3 field transported in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split volume
  !> @return The cell volume after transport in y
  function get_adv_detj_y(self, mesh_id, strang) result(detj_at_w3)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: detj_at_w3
    character(str_def)                                :: field_name

    field_name = 'adv_detj_y'
    if (strang) then
      detj_at_w3 => self%adv_detj_y_half(self%idx_from_mesh_id(mesh_id))
    else
      detj_at_w3 => self%adv_detj_y(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(detj_at_w3, field_name, mesh_id)

  end function get_adv_detj_y

  !> @brief Returns a pointer to the detj_at_w3 field transported in x and y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split volume
  !> @return The cell volume after transport in x and y
  function get_adv_detj_xy(self, mesh_id, strang) result(detj_at_w3)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: detj_at_w3
    character(str_def)                                :: field_name

    field_name = 'adv_detj_xy'
    if (strang) then
      detj_at_w3 => self%adv_detj_xy_half(self%idx_from_mesh_id(mesh_id))
    else
      detj_at_w3 => self%adv_detj_xy(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(detj_at_w3, field_name, mesh_id)

  end function get_adv_detj_xy

  !> @brief Returns a pointer to the fractional vertical wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical as to whether to return VHV frac wind
  !> @return The fractional vertical wind at W2v DOFs
  function get_frac_wind_z(self, mesh_id, strang) result(frac_wind_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: frac_wind_z

    if (strang) then
      frac_wind_z => self%frac_wind_z_half(self%idx_from_mesh_id(mesh_id))
    else
      frac_wind_z => self%frac_wind_z(self%idx_from_mesh_id(mesh_id))
    end if

  end function get_frac_wind_z

  !> @brief Returns a pointer to the fractional horizontal wind flux
  !> @param[in] mesh_id     The ID of the mesh to get the object for
  !> @param[in] strang      Logical for whether values are from HVH splitting
  !> @param[in] outer_step  Logical for whether wind is from outer step
  !> @return The fractional wind flux at W2h DOFs
  function get_frac_wind_xy(self, mesh_id, strang, outer_step) result(frac_wind_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: frac_wind_xy

    if (strang .and. outer_step) then
      frac_wind_xy => self%frac_wind_oxy_half(self%idx_from_mesh_id(mesh_id))
    else if (strang) then
      frac_wind_xy => self%frac_wind_xy_half(self%idx_from_mesh_id(mesh_id))
    else if (outer_step) then
      frac_wind_xy => self%frac_wind_oxy(self%idx_from_mesh_id(mesh_id))
    else
      frac_wind_xy => self%frac_wind_xy(self%idx_from_mesh_id(mesh_id))
    end if

  end function get_frac_wind_xy

  !> @brief Returns a pointer to the consistent tracer departure points
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the departure points for.
  !!                         Note that if there is substepping then this
  !!                         argument has the form
  !!                         (substep-1) * n_step + split_step_number
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The tracer departure points at W2 DoFs
  function get_tracer_dep_dist_xy(self, mesh_id, step, outer_step) result(tracer_dep_points_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_xy
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'tracer_dep_points_ox'
      tracer_dep_points_xy => self%tracer_dep_dist_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'tracer_dep_points_ix'
      tracer_dep_points_xy => self%tracer_dep_dist_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(tracer_dep_points_xy, field_name, mesh_id)

  end function get_tracer_dep_dist_xy

  !> @brief Returns a pointer to the consistent z departure points
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the departure points for.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * n_step + split_step_number
  !> @return The consistent departure points for the z direction at W2 DoFs
  function get_tracer_dep_dist_z(self, mesh_id, step) result(tracer_dep_points_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_z
    character(str_def)                                :: field_name

    field_name = 'tracer_dep_points_z'
    tracer_dep_points_z => self%tracer_dep_dist_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(tracer_dep_points_z, field_name, mesh_id)

  end function get_tracer_dep_dist_z

  !> @brief Returns a pointer to the dry inner fractional flux
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the fractional flux for.
  !!                         Note that if there is substepping then this
  !!                         argument has the form
  !!                         (substep-1) * n_step + split_step_number
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The dry inner fractional flux
  function get_dry_frac_flux_xy(self, mesh_id, step, outer_step) result(dry_frac_flux_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_xy
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'dry_frac_flux_ox'
      dry_frac_flux_xy => self%dry_frac_flux_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'dry_frac_flux_ix'
      dry_frac_flux_xy => self%dry_frac_flux_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(dry_frac_flux_xy, field_name, mesh_id)

  end function get_dry_frac_flux_xy

  !> @brief Returns a pointer to the consistent z fractional flux
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the fractional flux for.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * n_step + split_step_number
  !> @return The consistent fractional flux for the z direction
  function get_dry_frac_flux_z(self, mesh_id, step) result(dry_frac_flux_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_z
    character(str_def)                                :: field_name

    field_name = 'dry_frac_flux_z'
    dry_frac_flux_z => self%dry_frac_flux_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_frac_flux_z, field_name, mesh_id)

  end function get_dry_frac_flux_z

  !> @brief Returns a pointer to the transport of unity in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether values are from Strang splitting
  !> @return The update of transport of unity in x
  function get_adv_unity_x(self, mesh_id, strang) result(adv_unity_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: adv_unity_x
    character(str_def)                                :: field_name

    field_name = 'adv_unity_x'
    if (strang) then
      adv_unity_x => self%adv_unity_half_x(self%idx_from_mesh_id(mesh_id))
    else
      adv_unity_x => self%adv_unity_x(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(adv_unity_x, field_name, mesh_id)

  end function get_adv_unity_x

  !> @brief Returns a pointer to the transport of unity in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether values are from Strang splitting
  !> @return The update of transport of unity in y
  function get_adv_unity_y(self, mesh_id, strang) result(adv_unity_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: adv_unity_y
    character(str_def)                                :: field_name

    field_name = 'adv_unity_y'
    if (strang) then
      adv_unity_y => self%adv_unity_half_y(self%idx_from_mesh_id(mesh_id))
    else
      adv_unity_y => self%adv_unity_y(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(adv_unity_y, field_name, mesh_id)

  end function get_adv_unity_y


  !> @brief Returns a pointer to the transport of unity in z
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether values are from Strang splitting
  !> @return The update of transport of unity in z
  function get_adv_unity_z(self, mesh_id, strang) result(adv_unity_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: adv_unity_z
    character(str_def)                                :: field_name

    field_name = 'adv_unity_z'
    if (strang) then
      adv_unity_z => self%adv_unity_half_z(self%idx_from_mesh_id(mesh_id))
    else
      adv_unity_z => self%adv_unity_z(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(adv_unity_z, field_name, mesh_id)

  end function get_adv_unity_z


  !> @brief Returns a pointer to the vertical interpolation coefficients
  !!        for semi-Lagrangian transport of a W3 or Wtheta field
  !> @param[in] field   The field to apply the coefficients to
  !> @param[in] order   The order of the coefficients
  !> @param[in] number  Which coefficient number to get
  !!                    (1-4 for cubic, 1-6 for quintic, 1-2 for linear)
  !> @return The SL interpolation coefficients
  function get_vert_sl_coef(self, field, order, number) result(coef)

    use fs_continuity_mod,             only: W3, Wtheta
    use transport_config_mod,          only: vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    integer(kind=i_def),                   intent(in) :: order
    integer(kind=i_def),                   intent(in) :: number
    type(r_tran_field_type),               pointer    :: coef

    integer(kind=i_def) :: mesh_id

    ! Get mesh ID
    mesh_id = field%get_mesh_id()

    ! self%vert_cubic/quintic_coef array has index (mesh,function_space,coefficient_number)

    select case ( field%which_function_space() )
    case ( W3 )
      if (order == vertical_sl_order_cubic) then
        ! Cubic coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 1, number)
      else if (order == vertical_sl_order_cubic_hermite) then
        ! Cubic-Hermite coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 3, number)
      else if (order == vertical_sl_order_quintic) then
        ! Quintic coefficients
        coef => self%vert_quintic_coef(self%idx_from_mesh_id(mesh_id), 1, number)
      else
        ! Linear coefficients
        coef => self%vert_linear_coef(self%idx_from_mesh_id(mesh_id), 1, number)
      end if
    case ( Wtheta )
      if (order == vertical_sl_order_cubic) then
        ! Cubic coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 2, number)
      else if (order == vertical_sl_order_cubic_hermite) then
        ! Cubic-Hermite coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 4, number)
      else if (order == vertical_sl_order_quintic) then
        ! Quintic coefficients
        coef => self%vert_quintic_coef(self%idx_from_mesh_id(mesh_id), 2, number)
      else
        ! Linear coefficients
        coef => self%vert_linear_coef(self%idx_from_mesh_id(mesh_id), 2, number)
      end if
    case default
      call log_event( "get_vert_sl_coef only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

  end function get_vert_sl_coef

  !> @brief Returns a pointer to the vertical interpolation indices
  !!        for semi-Lagrangian transport of a W3/Wtheta field
  !> @param[in] field   The field to apply the coefficients to
  !> @param[in] order   The order of the coefficients for the index
  !> @param[in] number  Which coefficient index to get
  !!                    (1-4 for cubic, 1-6 for quintic, 1-2 for linear)
  !> @return The SL indices
  function get_vert_sl_index(self, field, order, number) result(index)

    use fs_continuity_mod,             only: W3, Wtheta
    use transport_config_mod,          only: vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    integer(kind=i_def),                   intent(in) :: order
    integer(kind=i_def),                   intent(in) :: number
    type(integer_field_type),              pointer    :: index

    integer(kind=i_def) :: mesh_id

    ! Get mesh ID
    mesh_id = field%get_mesh_id()

    ! self%vert_cubic/quintic_index array has index (mesh,function_space,coefficient_number)

    select case ( field%which_function_space() )
    case ( W3 )
      select case ( order )
      case (vertical_sl_order_cubic)
        ! Cubic coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),1,number)
      case (vertical_sl_order_cubic_hermite)
        ! Cubic-Hermite coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),3,number)
      case (vertical_sl_order_quintic)
        ! Quintic coefficients index
        index => self%vert_quintic_index(self%idx_from_mesh_id(mesh_id),1,number)
      end select
    case ( Wtheta )
      select case ( order )
      case (vertical_sl_order_cubic)
        ! Cubic coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),2,number)
      case (vertical_sl_order_cubic_hermite)
        ! Cubic-Hermite coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),4,number)
      case (vertical_sl_order_quintic)
        ! Quintic coefficients index
        index => self%vert_quintic_index(self%idx_from_mesh_id(mesh_id),2,number)
      end select
    case default
      call log_event( "get_vert_sl_index only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

  end function get_vert_sl_index

  !> @brief Returns a pointer to required stencil size for FFSL transport
  !!        based on the maximum horizontal departure distance
  !> @param[in] mesh_id     The ID of the mesh to get the object for
  !> @param[in] outer_step  Logical indicating whether to return value for outer step
  !> @return The required stencil depth
  function get_dep_stencil_extent_xy(self, mesh_id, outer_step) result(dep_stencil_extent_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_xy

    if (outer_step) then
      dep_stencil_extent_xy => self%dep_stencil_extent_oxy(self%idx_from_mesh_id(mesh_id))
    else
      dep_stencil_extent_xy => self%dep_stencil_extent_xy(self%idx_from_mesh_id(mesh_id))
    end if

  end function get_dep_stencil_extent_xy

  !> @brief Returns a pointer to required stencil size for consistent FFSL
  !!        transport based on the maximum horizontal inner departure distance
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for.
  !!                         Note that if there is substepping then this
  !!                         argument has the form
  !!                         (substep-1) * n_step + split_step_number
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The required stencil depth
  function get_tracer_stencil_extent_xy(self, mesh_id, step, outer_step) result(dep_stencil_extent_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_xy

    if (outer_step) then
      dep_stencil_extent_xy => self%tracer_stencil_extent_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      dep_stencil_extent_xy => self%tracer_stencil_extent_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_stencil_extent_xy

  !> @brief Returns whether the transport step is a cheap update step
  !!        or a regular transport step.
  !> @details The apply_cheap_update logical is used to tell
  !!          the transport scheme whether to use the full transport
  !!          scheme, or to revert to the cheap update transport scheme.
  !> @return Logical set to true if the cheap update flag is true and
  !!         it is not the first semi-implicit outer iteration
  function get_apply_cheap_update(self) result(apply_cheap_update)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    logical(kind=l_def)                               :: apply_cheap_update

    apply_cheap_update = self%apply_cheap_update

  end function get_apply_cheap_update

  !> @brief Returns number of split transport steps for the dry density
  !> @return The number of split transport steps for the dry density
  function get_num_dry_steps(self) result(num_dry_steps)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: num_dry_steps

    num_dry_steps = self%num_dry_steps

  end function get_num_dry_steps

  !> @brief Returns a pointer stored field at the start of the time step
  !> @return The field at the start of the time step
  function get_field_n(self) result(field_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               pointer    :: field_n

    field_n => self%field_n

  end function get_field_n

  !> @brief Returns a pointer to a dry density field from FFSL
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the density.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * (n_step+1) + dry_step_number
  !> @return The dry density field after its transport
  function get_rho_d(self, mesh_id, step) result(rho_d)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d
    character(str_def)                                :: field_name

    field_name = 'rho_d'
    rho_d => self%rho_d(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d, field_name, mesh_id)

  end function get_rho_d

  !> @brief Returns a pointer to a dry mass field
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the density.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * (n_step+1) + dry_step_number
  !> @return The dry mass field after its transport
  function get_dry_mass(self, mesh_id, step) result(dry_mass)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_mass
    character(str_def)                                :: field_name

    field_name = 'dry_mass'
    dry_mass => self%dry_mass(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_mass, field_name, mesh_id)

  end function get_dry_mass

  !> @brief Returns a pointer to a dry density field from an FFSL x-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the density.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * n_step + dry_step_number
  !> @return The dry density field after its FFSL x-sweep transport
  function get_dry_mass_ffsl_x(self, mesh_id, step) result(dry_mass_ffsl)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_mass_ffsl
    character(str_def)                                :: field_name

    field_name = 'dry_mass_ffsl_x'
    dry_mass_ffsl => self%dry_mass_ffsl_x(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_mass_ffsl, field_name, mesh_id)

  end function get_dry_mass_ffsl_x

  !> @brief Returns a pointer to a dry density field from an FFSL y-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the density.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * n_step + dry_step_number
  !> @return The dry density field after its FFSL y-sweep transport
  function get_dry_mass_ffsl_y(self, mesh_id, step) result(dry_mass_ffsl)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_mass_ffsl
    character(str_def)                                :: field_name

    field_name = 'dry_mass_ffsl_y'
    dry_mass_ffsl => self%dry_mass_ffsl_y(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_mass_ffsl, field_name, mesh_id)

  end function get_dry_mass_ffsl_y

  !> @brief Returns a pointer to a mass flux for a particular step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the mass flux
  !> @return The mass flux
  function get_flux(self, mesh_id, step) result(flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: flux

    flux => self%flux(self%idx_from_mesh_id(mesh_id), step)

  end function get_flux

  !> @brief Returns a pointer to the flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The step from which to return the dry flux.
  !!                    Note that if there is substepping then this
  !!                    argument has the form
  !!                    (substep-1) * n_step + dry_step_number
  !> @return The dry density flux
  function get_dry_flux(self, mesh_id, step) result(dry_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_flux
    character(str_def)                                :: field_name

    field_name = 'dry_flux'
    dry_flux => self%dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_flux, field_name, mesh_id)

  end function get_dry_flux

  !> @brief Returns a pointer to a volume field
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The volume field after its transport
  function get_detj_unity(self, mesh_id, step) result(detj_unity_3d)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: detj_unity_3d
    character(str_def)                                :: field_name

    field_name = 'detj_unity'
    detj_unity_3d => self%detj_unity(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(detj_unity_3d, field_name, mesh_id)

  end function get_detj_unity

  !> @brief Returns a pointer to a volume field from an FFSL x-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The volume field after its transport
  function get_detj_unity_x(self, mesh_id, step) result(detj_unity)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: detj_unity
    character(str_def)                                :: field_name

    field_name = 'detj_unity_x'
    detj_unity => self%detj_unity_x(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(detj_unity, field_name, mesh_id)

  end function get_detj_unity_x

  !> @brief Returns a pointer to a volume field from an FFSL y-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The volume field after its transport
  function get_detj_unity_y(self, mesh_id, step) result(detj_unity)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: detj_unity
    character(str_def)                                :: field_name

    field_name = 'detj_unity_y'
    detj_unity => self%detj_unity_y(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(detj_unity, field_name, mesh_id)

  end function get_detj_unity_y

  !> @brief Returns a pointer to required stencil size for unity
  !!        transport based on the maximum horizontal inner departure distance
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The required stencil depth
  function get_unity_stencil_extent_xy(self, mesh_id, step, outer_step) result(dep_stencil_extent_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_xy

    if (outer_step) then
      dep_stencil_extent_xy => self%unity_stencil_extent_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      dep_stencil_extent_xy => self%unity_stencil_extent_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_unity_stencil_extent_xy

  !> @brief Returns a pointer to the unity departure points
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the departure points for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The unity departure points at W2 DoFs
  function get_unity_dep_dist_xy(self, mesh_id, step, outer_step) result(unity_dep_points_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: unity_dep_points_xy
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'unity_dep_points_ox'
      unity_dep_points_xy => self%unity_dep_dist_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'unity_dep_points_ix'
      unity_dep_points_xy => self%unity_dep_dist_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(unity_dep_points_xy, field_name, mesh_id)

  end function get_unity_dep_dist_xy

  !> @brief Returns a pointer to the unity departure points
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the departure points for
  !> @return The unity departure points for the z direction at W2 DoFs
  function get_unity_dep_dist_z(self, mesh_id, step) result(unity_dep_points_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: unity_dep_points_z
    character(str_def)                                :: field_name

    field_name = 'unity_dep_points_z'
    unity_dep_points_z => self%unity_dep_dist_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(unity_dep_points_z, field_name, mesh_id)

  end function get_unity_dep_dist_z

  !> @brief Returns a pointer to the fractional part of the unity wind
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the fractional flux for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The fractional part of the unity wind
  function get_unity_frac_wind_xy(self, mesh_id, step, outer_step) result(unity_frac_wind_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: unity_frac_wind_xy
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'unity_frac_wind_ox'
      unity_frac_wind_xy => self%unity_frac_wind_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'unity_frac_wind_ix'
      unity_frac_wind_xy => self%unity_frac_wind_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(unity_frac_wind_xy, field_name, mesh_id)

  end function get_unity_frac_wind_xy

  !> @brief Returns a pointer to the fractional part of the unity wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the fractional flux for
  !> @return The fractional part of the unity wind for the z direction
  function get_unity_frac_wind_z(self, mesh_id, step) result(unity_frac_wind_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: unity_frac_wind_z
    character(str_def)                                :: field_name

    field_name = 'unity_frac_wind_z'
    unity_frac_wind_z => self%unity_frac_wind_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(unity_frac_wind_z, field_name, mesh_id)

  end function get_unity_frac_wind_z

  !> @brief Returns the counter of tracer transport steps
  !> @return The tracer step counter
  function get_tracer_step_ctr(self) result(tracer_step_ctr)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def) :: tracer_step_ctr

    tracer_step_ctr = self%tracer_step_ctr

  end function get_tracer_step_ctr

  !> @brief Returns the counter of tracer transport sub steps
  !> @return The tracer sub step counter
  function get_substep_total_ctr(self) result(substep_total_ctr)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def) :: substep_total_ctr

    substep_total_ctr = self%substep_total_ctr

  end function get_substep_total_ctr

  !> @brief Returns the index of tracer transport sub steps
  !!        and split steps in the form
  !!        (substep - 1)*(n_step + option)
  !> @param[in] option Storage above n_step for each substep. This is
  !!                   generally zero (for fields stored at each split
  !!                   step, such as fluxes) or one (for fields stored
  !!                   initially and at each split step, such as dry mass).
  !> @return The sub step and step index
  function get_substep_total_index(self,option) result(substep_total_index)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: option
    integer(kind=i_def) :: substep_total_index

    substep_total_index = (self%substep_total_ctr - 1) * &
                          (self%num_dry_steps + option)

  end function get_substep_total_index

  !> @brief Returns the flag to do the first outer transport advectively
  !> @return The advective flag
  function get_advective_flag(self) result(advective_flag)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    logical(kind=l_def) :: advective_flag

    advective_flag = self%advective_first_outer

  end function get_advective_flag

  !> @brief Returns the flag to do the first outer transport
  !!        without monotonicity
  !> @return The no monotonicity flag
  function get_no_mono_flag(self) result(no_mono_flag)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    logical(kind=l_def) :: no_mono_flag

    no_mono_flag = self%no_mono_first_outer

  end function get_no_mono_flag

! ============================================================================ !
! UTILITIES
! ============================================================================ !

  !> @brief Increments the counter of tracer transport steps
  subroutine inc_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = self%tracer_step_ctr + 1

  end subroutine inc_tracer_step_ctr

  !> @brief Resets the counter of tracer transport steps
  subroutine reset_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = 1

  end subroutine reset_tracer_step_ctr

  !> @brief Computes the total number of rho transport steps
  !> @result    num_dry_steps    Total number of transport steps for rho
  function compute_num_dry_steps(self) result(num_dry_steps)

    use transport_config_mod, only: splitting

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    ! Internal variables
    integer(kind=i_def) :: num_dry_steps

    ! Compute total number of split steps
    select case(splitting(self%dry_config))
    case(splitting_strang_hvh, splitting_strang_vhv)
      num_dry_steps = 3
    case(splitting_hv, splitting_vh)
      num_dry_steps = 2
    case(splitting_none)
      num_dry_steps = 1
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented with ' // &
        'consistent tracer transport'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function compute_num_dry_steps

  !> @brief Finds the index in the array of config variables corresponding to
  !!        the dry density
  subroutine find_dry_config(self)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              dry_field_name

    ! Arguments
    class(transport_runtime_type), target, intent(inout) :: self
    ! Internal variables
    integer(kind=i_def) :: config

    ! Extract dry density metadata
    self%dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        self%dry_config_found = .true.
        self%dry_config = config
        exit
      end if
    end do

    if (.not. self%dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up compute dry steps ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if


  end subroutine

  !> @brief Returns the function space for the direction of the dry step
  !> @param[in] step  Index of the dry density splitting step
  !> @result    fs    Enumerator for the W2 function space
  function direction_w2_fs(self, step) result(fs)

    use transport_config_mod, only: splitting

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: step
    ! Internal variables
    integer(kind=i_def) :: fs

    ! Compute total number of split steps
    select case(splitting(self%dry_config))
    case(splitting_strang_hvh)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      case default
        fs = 0
      end select
    case(splitting_strang_vhv)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      case default
        fs = 0
      end select
    case(splitting_hv)
      select case(step)
      case(1_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      case default
        fs = 0
      end select
    case(splitting_vh)
      select case(step)
      case(1_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      case default
        fs = 0
      end select
    case(splitting_none)
      fs = W2
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function direction_w2_fs

  !> @brief Returns the fraction to multiply dt for this splitting step
  !> @param[in] step      Index of the dry density splitting step
  !> @result    fraction  The multiplying fraction
  function splitting_fraction(self, step) result(fraction)

    use transport_config_mod, only: splitting

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: step
    ! Internal variables
    real(kind=r_tran) :: fraction

    ! Compute total number of split steps
    select case(splitting(self%dry_config))
    case(splitting_strang_hvh, splitting_strang_vhv)
      select case(step)
      case(1_i_def, 3_i_def)
        fraction = 0.5_r_tran
      case(2_i_def)
        fraction = 1.0_r_tran
      end select
    case(splitting_hv, splitting_vh, splitting_none)
      fraction = 1.0_r_tran
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function splitting_fraction

  !> @brief Private function for getting array index corresponding to mesh_id
  !> @param[in] self      The transport_runtime object
  !> @param[in] mesh_id   Identifier of mesh to find
  function idx_from_mesh_id(self, mesh_id) result(idx)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def)                               :: idx
    integer(kind=i_def)                               :: i

    idx = imdi
    do i = 1, self%n_meshes
      if ( mesh_id == self%mesh_ids(i) ) idx = i
    end do

    if ( idx == imdi ) then
      write(log_scratch_space, '(A,I4)') 'transport_runtime does not contain mesh: ', &
                                          mesh_id
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end function idx_from_mesh_id

  !> @brief Checks a field for values less than epsilon, and throws an error
  !!        if these values exist
  !> @details It is not possible to compute sensible consistent departure
  !!          distances for tracers if the dry mass is no longer positive.
  subroutine check_negative_field(self, field, field_name)

    use sci_field_minmax_alg_mod, only: get_field_minmax, get_local_field_minmax

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    character(len=*),                      intent(in) :: field_name

    ! Internal variables
    real(kind=r_tran) :: field_min
    real(kind=r_tran) :: field_max

    if (log_level() <= LOG_LEVEL_INFO) then
      ! Global min/max is more expensive but makes failure easier to spot
      call get_field_minmax(field, field_min, field_max)
    else
      ! For more sparse logging, avoid the global communication
      call get_local_field_minmax(field, field_min, field_max)
    end if

    if (field_min < EPS_R_TRAN) then
      write(log_scratch_space, '(A,E16.8,A,E16.8,A)')                          &
        'The minimum of field ' // adjustl(trim(field_name)) // ' is ',        &
        field_min, ' which is below the tolerance of ', EPS_R_TRAN,            &
        ' which makes it impossible to find consistent departure distances. '  &
        // 'Most likely the transporting wind has a maximum Lipschitz number ' &
        // 'that exceeds 1. Stopping model rather than continuing'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end subroutine check_negative_field

end module transport_runtime_alg_mod
